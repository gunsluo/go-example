// Package models contains the types for schema 'luoji'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"strconv"
	"strings"

	graphql "github.com/graph-gophers/graphql-go"
	"github.com/pkg/errors"
)

// Account represents a row from 'accounts'.
type Account struct {
	ID      int64           `json:"id" db:"id"`           // id
	Balance sql.NullFloat64 `json:"balance" db:"balance"` // balance

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Account exists in the database.
func (a *Account) Exists() bool {
	return a._exists
}

// Deleted provides information if the Account has been deleted from the database.
func (a *Account) Deleted() bool {
	return a._deleted
}

// Insert inserts the Account to the database.
func (a *Account) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if a._exists {
		return errors.New("insert failed: already exists")
	}

	params := make([]interface{}, 0, 1)
	fields := make([]string, 0, 1)
	retCols := "id"
	retVars := make([]interface{}, 0, 2)
	retVars = append(retVars, &a.ID)

	fields = append(fields, "id")
	params = append(params, a.ID)
	if a.Balance.Valid {
		fields = append(fields, "balance")
		params = append(params, a.Balance)
	} else {
		retCols += ", balance"
		retVars = append(retVars, &a.Balance)
	}

	if len(params) == 0 {
		// FIXME(jackie): maybe we should allow this?
		return errors.New("all fields are empty, unable to insert")
	}
	var placeHolders string
	for i := range params {
		placeHolders += "$" + strconv.Itoa(i+1)
		if i < len(params)-1 {
			placeHolders += ", "
		}
	}
	sqlstr := `INSERT INTO "accounts" (` +
		strings.Join(fields, ",") +
		`) VALUES (` + placeHolders +
		`) RETURNING ` + retCols

	err = db.QueryRow(sqlstr, params...).Scan(retVars...)
	if err != nil {
		return err
	}

	// set existence
	a._exists = true

	return nil
}

// Update updates the Account in the database.
func (a *Account) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !a._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if a._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE "accounts" SET (` +
		`balance` +
		`) = ( ` +
		`$1` +
		`) WHERE id = $2`

	// run query
	XOLog(sqlstr, a.Balance, a.ID)
	_, err = db.Exec(sqlstr, a.Balance, a.ID)
	return err
}

// Save saves the Account to the database.
func (a *Account) Save(db XODB) error {
	if a.Exists() {
		return a.Update(db)
	}

	return a.Insert(db)
}

// Upsert performs an upsert for Account.
//
// NOTE: PostgreSQL 9.5+ only
func (a *Account) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if a._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO "accounts" (` +
		`id, balance` +
		`) VALUES (` +
		`$1, $2` +
		`) ON CONFLICT (id) DO UPDATE SET (` +
		`id, balance` +
		`) = (` +
		`EXCLUDED.id, EXCLUDED.balance` +
		`)`

	// run query
	XOLog(sqlstr, a.ID, a.Balance)
	_, err = db.Exec(sqlstr, a.ID, a.Balance)
	if err != nil {
		return err
	}

	// set existence
	a._exists = true

	return nil
}

// Delete deletes the Account from the database.
func (a *Account) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !a._exists {
		return nil
	}

	// if deleted, bail
	if a._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM "accounts" WHERE id = $1`

	// run query
	XOLog(sqlstr, a.ID)
	_, err = db.Exec(sqlstr, a.ID)
	if err != nil {
		return err
	}

	// set deleted
	a._deleted = true

	return nil
}

// AccountFilter related to AccountQueryArguments
// struct field name contain table column name in Camel style and logic operator(lt, gt etc)
// only indexed column and special column defined in sqlSpecColFilterCtlMap declared in file xo/internal/funcs.go
type AccountFilter struct {
	Conjunction *string  // enum in "AND", "OR", nil(consider as single condition)
	Balance     *float64 `json:"balance"`     // equal to Balance
	BalanceLt   *float64 `json:"balance_lt"`  // less than Balance
	BalanceLte  *float64 `json:"balance_lte"` // less than and equal to Balance
	BalanceGt   *float64 `json:"balance_gt"`  // greater than Balance
	BalanceGte  *float64 `json:"balance_gte"` // greater than and equal to Balance
}

// AccountQueryArguments composed by Cursor, AccountFilter and sql filter string
type AccountQueryArguments struct {
	Cursor
	Where *AccountFilter

	// non-export field
	filterArgs *filterArguments
}

// getAccountFilter return the sql filter
func getAccountFilter(filter *AccountFilter) (*filterArguments, error) {
	if filter == nil {
		return nil, nil
	}
	conjunction := ""
	conjCnt := 0
	var filterPairs []*filterPair
	if filter.Conjunction != nil {
		conjunction = *filter.Conjunction
		if _, ok := sqlConjunctionMap[conjunction]; !ok {
			return nil, fmt.Errorf("unsupported conjunction:%v", filter.Conjunction)
		}
	}
	if filter.Balance != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "balance", option: "=", value: *filter.Balance})
	}
	if filter.BalanceLt != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "balance", option: "<", value: *filter.BalanceLt})
	} else if filter.BalanceLte != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "balance", option: "<=", value: *filter.BalanceLte})
	}
	if filter.BalanceGt != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "balance", option: ">", value: *filter.BalanceGt})
	} else if filter.BalanceGte != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "balance", option: ">=", value: *filter.BalanceGte})
	}
	if conjCnt == 0 {
		return nil, nil
	}
	if len(conjunction) > 0 && conjCnt < 2 {
		return nil, fmt.Errorf("invalid filter conjunction: %v need more than 2 parameter but have: %v", *filter.Conjunction, conjCnt)
	}
	if len(conjunction) == 0 && conjCnt != 1 {
		return nil, fmt.Errorf("multi field:%v should be connected by conjunction AND or OR", conjCnt)
	}
	filterArgs := &filterArguments{filterPairs: filterPairs, conjunction: conjunction, conjCnt: conjCnt}
	return filterArgs, nil
}

// ApplyAccountQueryArgsDefaults assigns default cursor values to non-nil fields.
func ApplyAccountQueryArgsDefaults(queryArgs *AccountQueryArguments) *AccountQueryArguments {
	if queryArgs == nil {
		queryArgs = &AccountQueryArguments{
			Cursor: DefaultCursor,
		}
		return queryArgs
	}
	if queryArgs.Offset == nil {
		queryArgs.Offset = DefaultCursor.Offset
	}
	if queryArgs.Limit == nil {
		queryArgs.Limit = DefaultCursor.Limit
	}
	if queryArgs.Index == nil {
		queryArgs.Index = DefaultCursor.Index
	}
	if queryArgs.Desc == nil {
		queryArgs.Desc = DefaultCursor.Desc
	}
	if queryArgs.Dead == nil {
		queryArgs.Dead = DefaultCursor.Dead
	}
	if queryArgs.After == nil {
		queryArgs.After = DefaultCursor.After
	}
	if queryArgs.First == nil {
		queryArgs.First = DefaultCursor.First
	}
	if queryArgs.Before == nil {
		queryArgs.Before = DefaultCursor.Before
	}
	if queryArgs.Last == nil {
		queryArgs.Last = DefaultCursor.Last
	}
	return queryArgs
}

// GetMostRecentAccount returns n most recent rows from 'luoji.accounts',
// ordered by "created_date" in descending order.
func GetMostRecentAccount(db XODB, n int) ([]*Account, error) {
	const sqlstr = `SELECT ` +
		`id, balance ` +
		`FROM "accounts" ` +
		`ORDER BY created_date DESC LIMIT $1`

	q, err := db.Query(sqlstr, n)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	var res []*Account
	for q.Next() {
		a := Account{}

		// scan
		err = q.Scan(&a.ID, &a.Balance)
		if err != nil {
			return nil, err
		}

		res = append(res, &a)
	}

	return res, nil
}

// GetMostRecentChangedAccount returns n most recent rows from 'luoji.accounts',
// ordered by "changed_date" in descending order.
func GetMostRecentChangedAccount(db XODB, n int) ([]*Account, error) {
	const sqlstr = `SELECT ` +
		`id, balance ` +
		`FROM "accounts" ` +
		`ORDER BY changed_date DESC LIMIT $1`

	q, err := db.Query(sqlstr, n)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	var res []*Account
	for q.Next() {
		a := Account{}

		// scan
		err = q.Scan(&a.ID, &a.Balance)
		if err != nil {
			return nil, err
		}

		res = append(res, &a)
	}

	return res, nil
}

// GetAllAccount returns all rows from 'luoji.accounts', based on the AccountQueryArguments.
// If the AccountQueryArguments is nil, it will use the default AccountQueryArguments instead.
func GetAllAccount(db XODB, queryArgs *AccountQueryArguments) ([]*Account, error) { // nolint: gocyclo
	queryArgs = ApplyAccountQueryArgsDefaults(queryArgs)

	desc := ""
	if *queryArgs.Desc {
		desc = "DESC"
	}

	dead := "NULL"
	if *queryArgs.Dead {
		dead = "NOT NULL"
	}

	var params []interface{}
	placeHolders := ""
	if queryArgs.filterArgs != nil {
		pls := make([]string, len(queryArgs.filterArgs.filterPairs))
		for i, pair := range queryArgs.filterArgs.filterPairs {
			pls[i] = fmt.Sprintf("%s %s $%d", pair.fieldName, pair.option, i+1)
			params = append(params, pair.value)
		}
		placeHolders = strings.Join(pls, " "+queryArgs.filterArgs.conjunction+" ")
		placeHolders = fmt.Sprintf("(%s) AND", placeHolders)
	}
	params = append(params, *queryArgs.Offset)
	offsetPos := len(params)

	params = append(params, *queryArgs.Limit)
	limitPos := len(params)
	var sqlstr = fmt.Sprintf(
		`SELECT %s FROM %s WHERE %s deleted_date IS %s ORDER BY %s %s OFFSET $%d LIMIT $%d`,
		`id, balance `,
		`"accounts"`,
		placeHolders,
		dead,
		"id",
		desc,
		offsetPos,
		limitPos)

	XOLog(sqlstr, params...)

	q, err := db.Query(sqlstr, params...)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	var res []*Account
	for q.Next() {
		a := Account{}

		// scan
		err = q.Scan(&a.ID, &a.Balance)
		if err != nil {
			return nil, err
		}

		res = append(res, &a)
	}

	return res, nil
}

// CountAllAccount returns a count of all rows from 'luoji.accounts'
func CountAllAccount(db XODB, queryArgs *AccountQueryArguments) (int, error) {
	queryArgs = ApplyAccountQueryArgsDefaults(queryArgs)

	dead := "NULL"
	if *queryArgs.Dead {
		dead = "NOT NULL"
	}

	var params []interface{}
	placeHolders := ""
	if queryArgs.filterArgs != nil {
		pls := make([]string, len(queryArgs.filterArgs.filterPairs))
		for i, pair := range queryArgs.filterArgs.filterPairs {
			pls[i] = fmt.Sprintf("%s %s $%d", pair.fieldName, pair.option, i+1)
			params = append(params, pair.value)
		}
		placeHolders = strings.Join(pls, " "+queryArgs.filterArgs.conjunction+" ")
		placeHolders = fmt.Sprintf("(%s) AND", placeHolders)
	}

	var err error
	var sqlstr = fmt.Sprintf(`SELECT count(*) from "accounts" WHERE %s deleted_date IS %s`, placeHolders, dead)
	XOLog(sqlstr)

	var count int
	err = db.QueryRow(sqlstr, params...).Scan(&count)
	if err != nil {
		return -1, err
	}
	return count, nil
}

const graphQLAccountQueries = `
	allAccounts(where: AccountFilter, offset: Int, limit: Int): AccountConnection!
	accountByID(id:ID!):Account
	accountsByBalance(balance:Float):[Account!]
`

const graphQLAccountMutations = `
	insertAccounts(input: [InsertAccountInput!]!): [Account!]!
	updateAccounts(input: [UpdateAccountInput!]!): [Account!]!
	deleteAccounts(input: [DeleteAccountInput!]!): [ID!]!
`

func (RootResolver) AllAccounts(ctx context.Context, args *AccountQueryArguments) (*AccountConnectionResolver, error) {
	return AllAccounts(ctx, args)
}

// AccountByID generated by primary
func (RootResolver) AccountByID(ctx context.Context, args struct {
	ID graphql.ID
}) (*AccountResolver, error) {
	return AccountByIDGraphQL(ctx, args)
}

// AccountsByBalance generated by balance_idx
func (RootResolver) AccountsByBalance(ctx context.Context, args struct {
	Balance *float64
}) (*[]AccountResolver, error) {
	return AccountsByBalanceGraphQL(ctx, args)
}

func (RootResolver) InsertAccounts(ctx context.Context, args struct{ Input []InsertAccountInput }) ([]AccountResolver, error) {
	return InsertAccountGraphQL(ctx, args.Input)
}

func (RootResolver) UpdateAccounts(ctx context.Context, args struct{ Input []UpdateAccountInput }) ([]AccountResolver, error) {
	return UpdateAccountGraphQL(ctx, args.Input)
}

func (RootResolver) DeleteAccounts(ctx context.Context, args struct{ Input []DeleteAccountInput }) ([]graphql.ID, error) {
	return DeleteAccountGraphQL(ctx, args.Input)
}

func GetAccountQueries() string {
	return graphQLAccountQueries
}

func GetAccountMutations() string {
	return graphQLAccountMutations
}

// GraphQLAccountTypes specifies the GraphQL types for Account
const GraphQLAccountTypes = `
	type Account {
		id: ID!
		balance: Float
	}

	type AccountConnection {
		pageInfo: PageInfo!
		edges: [AccountEdge]
		totalCount: Int
		accounts: [Account]
	}

	type AccountEdge {
		node: Account
		cursor: ID!
	}

	input AccountFilter {
		conjunction: FilterConjunction
		balance: Float
		balance_lt: Float
		balance_lte: Float
		balance_gt: Float
		balance_gte: Float
	}

	input InsertAccountInput {
		balance: Float
	}

	input UpdateAccountInput {
		id: ID!
		balance: Float
	}

	input DeleteAccountInput {
		id: ID!
	}
`

// AccountResolver defines the GraphQL resolver for 'Account'.
type AccountResolver struct{ node *Account }

func NewAccountResolver(node *Account) *AccountResolver {
	return &AccountResolver{node: node}
}
func (r AccountResolver) ID() graphql.ID    { return graphql.ID(strconv.FormatInt(r.node.ID, 10)) }
func (r AccountResolver) Balance() *float64 { return PointerFloat64SqlFloat64(r.node.Balance) }

// AccountConnectionResolver defines a GraphQL resolver for AccountConnection
type AccountConnectionResolver struct {
	data  []*Account
	count int32
}

// PageInfo returns PageInfo
func (r AccountConnectionResolver) PageInfo() *PageInfoResolver {
	if len(r.data) == 0 {
		return nil
	}

	return &PageInfoResolver{
		startCursor:     encodeCursor("Account", int(r.data[0].ID)),
		endCursor:       encodeCursor("Account", int(r.data[len(r.data)-1].ID)),
		hasNextPage:     false, // TODO
		hasPreviousPage: false, // TODO
	}
}

// Edges returns standard GraphQL edges
func (r AccountConnectionResolver) Edges() *[]*AccountEdgeResolver {
	edges := make([]*AccountEdgeResolver, len(r.data))

	for i := range r.data {
		edges[i] = &AccountEdgeResolver{node: r.data[i]}
	}
	return &edges
}

// TotalCount returns total count
func (r AccountConnectionResolver) TotalCount() *int32 {
	return &r.count
}

// Accounts returns the list of Account
func (r AccountConnectionResolver) Accounts() *[]*AccountResolver {
	data := make([]*AccountResolver, len(r.data))
	for i := range r.data {
		data[i] = &AccountResolver{r.data[i]}
	}
	return &data
}

// AccountEdgeResolver defines the Account edge
type AccountEdgeResolver struct {
	node *Account
}

// Node returns the Account node
func (r AccountEdgeResolver) Node() *AccountResolver {
	return &AccountResolver{r.node}
}

// Cursor returns the cursor
func (r AccountEdgeResolver) Cursor() graphql.ID {
	return encodeCursor("Account", int(r.node.ID))
}

// InsertAccountInput defines the insert Account mutation input
type InsertAccountInput struct {
	Balance *float64
}

// UpdateAccountInput defines the update Account mutation input
type UpdateAccountInput struct {
	ID      graphql.ID
	Balance *float64
}

// DeleteAccountInput defines the delete Account mutation input
type DeleteAccountInput struct {
	ID graphql.ID
}

// AllAccounts is the GraphQL end point for GetAllAccount
func AllAccounts(ctx context.Context, queryArgs *AccountQueryArguments) (*AccountConnectionResolver, error) { // nolint: gocyclo
	db, ok := ctx.Value(DBCtx).(XODB)
	if !ok {
		return nil, errors.New("db is not found in context")
	}

	if queryArgs != nil && (queryArgs.After != nil || queryArgs.First != nil || queryArgs.Before != nil || queryArgs.Last != nil) {
		return nil, errors.New("not implemented yet, use offset + limit for pagination")
	}

	queryArgs = ApplyAccountQueryArgsDefaults(queryArgs)

	filterArgs, err := getAccountFilter(queryArgs.Where)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get Account filter")
	}
	queryArgs.filterArgs = filterArgs

	allAccount, err := GetAllAccount(db, queryArgs)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get Account")
	}

	count, err := CountAllAccount(db, queryArgs)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get count")
	}

	return &AccountConnectionResolver{
		data:  allAccount,
		count: int32(count),
	}, nil
}

// InsertAccountGraphQL is the GraphQL end point for InsertAccount
func InsertAccountGraphQL(ctx context.Context, items []InsertAccountInput) ([]AccountResolver, error) {
	db, ok := ctx.Value(DBCtx).(XODB)
	if !ok {
		return nil, errors.New("db is not found in context")
	}
	results := make([]AccountResolver, len(items))
	for i := range items {
		input := items[i]

		f1 := Float64Pointer(input.Balance)
		node := &Account{
			Balance: f1,
		}
		if err := node.Insert(db); err != nil {
			return nil, errors.Wrap(err, "unable to insert Account")
		}
		results[i] = AccountResolver{node: node}
	}
	return results, nil
}

// UpdateAccountGraphQL is the GraphQL end point for UpdateAccount
func UpdateAccountGraphQL(ctx context.Context, items []UpdateAccountInput) ([]AccountResolver, error) {
	db, ok := ctx.Value(DBCtx).(XODB)
	if !ok {
		return nil, errors.New("db is not found in context")
	}
	results := make([]AccountResolver, len(items))
	for i := range items {
		input := items[i]
		id, err := strconv.ParseInt(string(input.ID), 10, 0)
		if err != nil {
			return nil, errors.New("ID must be an integer")
		}
		node := &Account{ID: id}
		fields := make([]string, 0, 1)
		params := make([]interface{}, 0, 1)
		retCols := make([]string, 0, 1)
		retVars := make([]interface{}, 0, 1)
		if input.Balance != nil {
			fields = append(fields, "balance")
			params = append(params, *input.Balance)
			node.Balance = sql.NullFloat64{Float64: *input.Balance, Valid: true}
		} else {
			retCols = append(retCols, "balance")
			retVars = append(retVars, &node.Balance)
		}
		if len(params) == 0 {
			return nil, errors.New("all fields are empty, unable to update")
		}
		var placeHolders string
		for i := range params {
			placeHolders += "$" + strconv.Itoa(i+1)
			if i < len(params)-1 {
				placeHolders += ", "
			}
		}
		params = append(params, id)
		sqlstr := `UPDATE "accounts" SET (` +
			strings.Join(fields, ",") +
			`) = (` + placeHolders +
			`) WHERE id = $` + strconv.Itoa(len(params)) +
			` RETURNING ` + strings.Join(retCols, ", ")
		if err := db.QueryRow(sqlstr, params...).Scan(retVars...); err != nil {
			return nil, err
		}

		results[i] = AccountResolver{node: node}
	}
	return results, nil
}

// DeleteAccountGraphQL is the GraphQL end point for DeleteAccount
func DeleteAccountGraphQL(ctx context.Context, items []DeleteAccountInput) ([]graphql.ID, error) {
	db, ok := ctx.Value(DBCtx).(XODB)
	if !ok {
		return nil, errors.New("db is not found in context")
	}
	// sql query
	const sqlstr = `DELETE FROM "accounts" WHERE id = $1`

	results := make([]graphql.ID, len(items))

	for i := range items {
		input := items[i]

		id, err := strconv.ParseInt(string(input.ID), 10, 0)
		if err != nil {
			return nil, errors.New("ID must be an integer")
		}

		XOLog(sqlstr, id)
		_, err = db.Exec(sqlstr, id)
		if err != nil {
			return nil, err
		}
		results[i] = input.ID
	}
	return results, nil
}

// AccountsByBalance retrieves a row from 'accounts' as a Account.
//
// Generated from index 'balance_idx'.
func AccountsByBalance(db XODB, balance sql.NullFloat64) ([]*Account, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, balance ` +
		`FROM "accounts" ` +
		`WHERE balance = $1`

	// run query
	XOLog(sqlstr, balance)
	q, err := db.Query(sqlstr, balance)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Account{}
	for q.Next() {
		a := Account{
			_exists: true,
		}

		// scan
		err = q.Scan(&a.ID, &a.Balance)
		if err != nil {
			return nil, err
		}

		res = append(res, &a)
	}

	return res, nil
}

// AccountsByBalanceGraphQL retrieves a row from 'accounts' as a Account.
//
// Generated from index 'balance_idx'.
func AccountsByBalanceGraphQL(ctx context.Context, args struct {
	Balance *float64
}) (*[]AccountResolver, error) {
	db, ok := ctx.Value(DBCtx).(XODB)
	if !(ok) {
		return nil, errors.New("db is not found in context")
	}

	panic("fix me in xo template postgres.index.go.tpl for sql.NullFloat64")

	data, err := AccountsByBalance(db, Float64Pointer(args.Balance))
	if err != nil {
		return nil, errors.Wrap(err, "unable to get accounts")
	}

	ret := make([]AccountResolver, len(data))
	for i, row := range data {
		ret[i] = AccountResolver{node: row}
	}
	return &ret, nil

}

// AccountByID retrieves a row from 'accounts' as a Account.
//
// Generated from index 'primary'.
func AccountByID(db XODB, id int64) (*Account, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, balance ` +
		`FROM "accounts" ` +
		`WHERE id = $1`

	// run query
	XOLog(sqlstr, id)
	a := Account{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&a.ID, &a.Balance)
	if err != nil {
		return nil, err
	}

	return &a, nil
}

// AccountByIDGraphQL retrieves a row from 'accounts' as a Account.
//
// Generated from index 'primary'.
func AccountByIDGraphQL(ctx context.Context, args struct {
	ID graphql.ID
}) (*AccountResolver, error) {
	db, ok := ctx.Value(DBCtx).(XODB)
	if !(ok) {
		return nil, errors.New("db is not found in context")
	}

	arg0, err := strconv.ParseInt(string(args.ID), 10, 64)
	if err != nil {
		return nil, errors.Wrap(err, "ID should be int64")
	}

	data, err := AccountByID(db, arg0)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get accounts")
	}

	return &AccountResolver{node: data}, nil

}
