/*
 * Identity
 *
 * Welcome to the Identity HTTP API documentation! You will find documentation for all HTTP APIs here.
 *
 * API version: latest
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package identityclient

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)

// Linger please
var (
	_ context.Context
)

type VerificationApi interface {

	/*
	 * GetVerificationFlowRequest # Get Verification Flow
	 * This endpoint returns a verification flow's context with, for example, error details and other information.

Browser flows expect the anti-CSRF cookie to be included in the request's HTTP Cookie Header.
For AJAX requests you must ensure that cookies are included in the request or requests will fail.

If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain
and you need to forward the incoming HTTP Cookie header to this endpoint:

```js
pseudo-code example
router.get('/recovery', async function (req, res) {
const flow = await client.getVerificationFlowRequest(req.header('cookie'), req.query['flow'])

res.render('verification', flow)
})
	 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return VerificationApiApiGetVerificationFlowRequestRequest
	 */
	GetVerificationFlowRequest(ctx context.Context) VerificationApiApiGetVerificationFlowRequestRequest

	/*
	 * GetVerificationFlowRequestExecute executes the request
	 * @return VerificationFlow
	 */
	GetVerificationFlowRequestExecute(r VerificationApiApiGetVerificationFlowRequestRequest) (*VerificationFlow, *http.Response, error)

	/*
	 * InitBrowserVerificationFlowRequest # Initialize Verification Flow for Browser Clients
	 * This endpoint initializes a browser-based account verification flow. Once initialized, the browser will be redirected to
`selfservice.flows.verification.ui_url` with the flow ID set as the query parameter `?flow=`.

If this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects.

This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...).
	 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return VerificationApiApiInitBrowserVerificationFlowRequestRequest
	 */
	InitBrowserVerificationFlowRequest(ctx context.Context) VerificationApiApiInitBrowserVerificationFlowRequestRequest

	/*
	 * InitBrowserVerificationFlowRequestExecute executes the request
	 * @return VerificationFlow
	 */
	InitBrowserVerificationFlowRequestExecute(r VerificationApiApiInitBrowserVerificationFlowRequestRequest) (*VerificationFlow, *http.Response, error)

	/*
	 * SubmitVerificationFlowRequest # Complete Verification Flow
	 * Use this endpoint to complete a verification flow. This endpoint
behaves differently for API and browser flows and has several states:

`choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent
and works with API- and Browser-initiated flows.
For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid
and a HTTP 303 See Other redirect with a fresh verification flow if the flow was otherwise invalid (e.g. expired).
For Browser clients without HTTP Header `Accept` or with `Accept: text/*` it returns a HTTP 303 See Other redirect to the Verification UI URL with the Verification Flow ID appended.
`sent_email` is the success state after `choose_method` when using the `captcha` method and allows the user to request another verification email. It
works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state.
`passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow ("sending a verification captcha")
does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL
(if the captcha was valid) and instructs the user to update their password, or a redirect to the Verification UI URL with
a new Verification Flow ID which contains an error message that the verification captcha was invalid.

More information can be found at:
	 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return VerificationApiApiSubmitVerificationFlowRequestRequest
	 */
	SubmitVerificationFlowRequest(ctx context.Context) VerificationApiApiSubmitVerificationFlowRequestRequest

	/*
	 * SubmitVerificationFlowRequestExecute executes the request
	 * @return VerificationFlow
	 */
	SubmitVerificationFlowRequestExecute(r VerificationApiApiSubmitVerificationFlowRequestRequest) (*VerificationFlow, *http.Response, error)
}

// VerificationApiService VerificationApi service
type VerificationApiService service

type VerificationApiApiGetVerificationFlowRequestRequest struct {
	ctx context.Context
	ApiService VerificationApi
	id *string
	cookie *string
}

func (r VerificationApiApiGetVerificationFlowRequestRequest) Id(id string) VerificationApiApiGetVerificationFlowRequestRequest {
	r.id = &id
	return r
}
func (r VerificationApiApiGetVerificationFlowRequestRequest) Cookie(cookie string) VerificationApiApiGetVerificationFlowRequestRequest {
	r.cookie = &cookie
	return r
}

func (r VerificationApiApiGetVerificationFlowRequestRequest) Execute() (*VerificationFlow, *http.Response, error) {
	return r.ApiService.GetVerificationFlowRequestExecute(r)
}

/*
 * GetVerificationFlowRequest # Get Verification Flow
 * This endpoint returns a verification flow's context with, for example, error details and other information.

Browser flows expect the anti-CSRF cookie to be included in the request's HTTP Cookie Header.
For AJAX requests you must ensure that cookies are included in the request or requests will fail.

If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain
and you need to forward the incoming HTTP Cookie header to this endpoint:

```js
pseudo-code example
router.get('/recovery', async function (req, res) {
const flow = await client.getVerificationFlowRequest(req.header('cookie'), req.query['flow'])

res.render('verification', flow)
})
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return VerificationApiApiGetVerificationFlowRequestRequest
 */
func (a *VerificationApiService) GetVerificationFlowRequest(ctx context.Context) VerificationApiApiGetVerificationFlowRequestRequest {
	return VerificationApiApiGetVerificationFlowRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return VerificationFlow
 */
func (a *VerificationApiService) GetVerificationFlowRequestExecute(r VerificationApiApiGetVerificationFlowRequestRequest) (*VerificationFlow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *VerificationFlow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerificationApiService.GetVerificationFlowRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/self-service/verification/flows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.cookie != nil {
		localVarHeaderParams["cookie"] = parameterToString(*r.cookie, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JsonErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v JsonErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VerificationApiApiInitBrowserVerificationFlowRequestRequest struct {
	ctx context.Context
	ApiService VerificationApi
	returnTo *string
	loginChallenge *string
}

func (r VerificationApiApiInitBrowserVerificationFlowRequestRequest) ReturnTo(returnTo string) VerificationApiApiInitBrowserVerificationFlowRequestRequest {
	r.returnTo = &returnTo
	return r
}
func (r VerificationApiApiInitBrowserVerificationFlowRequestRequest) LoginChallenge(loginChallenge string) VerificationApiApiInitBrowserVerificationFlowRequestRequest {
	r.loginChallenge = &loginChallenge
	return r
}

func (r VerificationApiApiInitBrowserVerificationFlowRequestRequest) Execute() (*VerificationFlow, *http.Response, error) {
	return r.ApiService.InitBrowserVerificationFlowRequestExecute(r)
}

/*
 * InitBrowserVerificationFlowRequest # Initialize Verification Flow for Browser Clients
 * This endpoint initializes a browser-based account verification flow. Once initialized, the browser will be redirected to
`selfservice.flows.verification.ui_url` with the flow ID set as the query parameter `?flow=`.

If this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects.

This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return VerificationApiApiInitBrowserVerificationFlowRequestRequest
 */
func (a *VerificationApiService) InitBrowserVerificationFlowRequest(ctx context.Context) VerificationApiApiInitBrowserVerificationFlowRequestRequest {
	return VerificationApiApiInitBrowserVerificationFlowRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return VerificationFlow
 */
func (a *VerificationApiService) InitBrowserVerificationFlowRequestExecute(r VerificationApiApiInitBrowserVerificationFlowRequestRequest) (*VerificationFlow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *VerificationFlow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerificationApiService.InitBrowserVerificationFlowRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/self-service/verification/browser"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnTo != nil {
		localVarQueryParams.Add("return_to", parameterToString(*r.returnTo, ""))
	}
	if r.loginChallenge != nil {
		localVarQueryParams.Add("login_challenge", parameterToString(*r.loginChallenge, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v JsonErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VerificationApiApiSubmitVerificationFlowRequestRequest struct {
	ctx context.Context
	ApiService VerificationApi
	flow *string
	submitVerificationFlowBody *SubmitVerificationFlowBody
	token *string
	cookie *string
}

func (r VerificationApiApiSubmitVerificationFlowRequestRequest) Flow(flow string) VerificationApiApiSubmitVerificationFlowRequestRequest {
	r.flow = &flow
	return r
}
func (r VerificationApiApiSubmitVerificationFlowRequestRequest) SubmitVerificationFlowBody(submitVerificationFlowBody SubmitVerificationFlowBody) VerificationApiApiSubmitVerificationFlowRequestRequest {
	r.submitVerificationFlowBody = &submitVerificationFlowBody
	return r
}
func (r VerificationApiApiSubmitVerificationFlowRequestRequest) Token(token string) VerificationApiApiSubmitVerificationFlowRequestRequest {
	r.token = &token
	return r
}
func (r VerificationApiApiSubmitVerificationFlowRequestRequest) Cookie(cookie string) VerificationApiApiSubmitVerificationFlowRequestRequest {
	r.cookie = &cookie
	return r
}

func (r VerificationApiApiSubmitVerificationFlowRequestRequest) Execute() (*VerificationFlow, *http.Response, error) {
	return r.ApiService.SubmitVerificationFlowRequestExecute(r)
}

/*
 * SubmitVerificationFlowRequest # Complete Verification Flow
 * Use this endpoint to complete a verification flow. This endpoint
behaves differently for API and browser flows and has several states:

`choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent
and works with API- and Browser-initiated flows.
For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid
and a HTTP 303 See Other redirect with a fresh verification flow if the flow was otherwise invalid (e.g. expired).
For Browser clients without HTTP Header `Accept` or with `Accept: text/*` it returns a HTTP 303 See Other redirect to the Verification UI URL with the Verification Flow ID appended.
`sent_email` is the success state after `choose_method` when using the `captcha` method and allows the user to request another verification email. It
works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state.
`passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow ("sending a verification captcha")
does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL
(if the captcha was valid) and instructs the user to update their password, or a redirect to the Verification UI URL with
a new Verification Flow ID which contains an error message that the verification captcha was invalid.

More information can be found at:
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return VerificationApiApiSubmitVerificationFlowRequestRequest
 */
func (a *VerificationApiService) SubmitVerificationFlowRequest(ctx context.Context) VerificationApiApiSubmitVerificationFlowRequestRequest {
	return VerificationApiApiSubmitVerificationFlowRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return VerificationFlow
 */
func (a *VerificationApiService) SubmitVerificationFlowRequestExecute(r VerificationApiApiSubmitVerificationFlowRequestRequest) (*VerificationFlow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *VerificationFlow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerificationApiService.SubmitVerificationFlowRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/self-service/verification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.flow == nil {
		return localVarReturnValue, nil, reportError("flow is required and must be specified")
	}
	if r.submitVerificationFlowBody == nil {
		return localVarReturnValue, nil, reportError("submitVerificationFlowBody is required and must be specified")
	}

	localVarQueryParams.Add("flow", parameterToString(*r.flow, ""))
	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.cookie != nil {
		localVarHeaderParams["Cookie"] = parameterToString(*r.cookie, "")
	}
	// body params
	localVarPostBody = r.submitVerificationFlowBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v VerificationFlow
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 410 {
			var v JsonErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v JsonErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
