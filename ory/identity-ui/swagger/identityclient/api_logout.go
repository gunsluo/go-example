/*
 * Identity
 *
 * Welcome to the Identity HTTP API documentation! You will find documentation for all HTTP APIs here.
 *
 * API version: latest
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package identityclient

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)

// Linger please
var (
	_ context.Context
)

type LogoutApi interface {

	/*
	 * InitBrowserLogoutFlowRequest # Create a Logout URL for Browsers
	 * This endpoint initializes a browser-based user logout flow and a URL which can be used to log out the user.

This endpoint is NOT INTENDED for API clients and only works
with browsers (Chrome, Firefox, ...). For API clients you can
call the `/self-service/logout/api` URL directly with the Session Token.

The URL is only valid for the currently signed in user. If no user is signed in, this endpoint returns
a 401 error.

When calling this endpoint from a backend, please ensure to properly forward the HTTP cookies.
	 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return LogoutApiApiInitBrowserLogoutFlowRequestRequest
	 */
	InitBrowserLogoutFlowRequest(ctx context.Context) LogoutApiApiInitBrowserLogoutFlowRequestRequest

	/*
	 * InitBrowserLogoutFlowRequestExecute executes the request
	 * @return InitBrowserLogoutFlowResponse
	 */
	InitBrowserLogoutFlowRequestExecute(r LogoutApiApiInitBrowserLogoutFlowRequestRequest) (*InitBrowserLogoutFlowResponse, *http.Response, error)

	/*
	 * SubmitLogoutFlowRequest # Complete Self-Service Logout
	 * This endpoint logs out an identity in a self-service manner.

If the `Accept` HTTP header is not set to `application/json`, the browser will be redirected (HTTP 303 See Other)
to the `return_to` parameter of the initial request or fall back to `urls.default_return_to`.

If the `Accept` HTTP header is set to `application/json`, a 204 No Content response
will be sent on successful logout instead.

This endpoint is NOT INTENDED for API clients and only works
with browsers (Chrome, Firefox, ...). For API clients you can
call the `/self-service/logout/api` URL directly with the Session Token.
	 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return LogoutApiApiSubmitLogoutFlowRequestRequest
	 */
	SubmitLogoutFlowRequest(ctx context.Context) LogoutApiApiSubmitLogoutFlowRequestRequest

	/*
	 * SubmitLogoutFlowRequestExecute executes the request
	 */
	SubmitLogoutFlowRequestExecute(r LogoutApiApiSubmitLogoutFlowRequestRequest) (*http.Response, error)
}

// LogoutApiService LogoutApi service
type LogoutApiService service

type LogoutApiApiInitBrowserLogoutFlowRequestRequest struct {
	ctx context.Context
	ApiService LogoutApi
	logoutChallenge *string
	cookie *string
}

func (r LogoutApiApiInitBrowserLogoutFlowRequestRequest) LogoutChallenge(logoutChallenge string) LogoutApiApiInitBrowserLogoutFlowRequestRequest {
	r.logoutChallenge = &logoutChallenge
	return r
}
func (r LogoutApiApiInitBrowserLogoutFlowRequestRequest) Cookie(cookie string) LogoutApiApiInitBrowserLogoutFlowRequestRequest {
	r.cookie = &cookie
	return r
}

func (r LogoutApiApiInitBrowserLogoutFlowRequestRequest) Execute() (*InitBrowserLogoutFlowResponse, *http.Response, error) {
	return r.ApiService.InitBrowserLogoutFlowRequestExecute(r)
}

/*
 * InitBrowserLogoutFlowRequest # Create a Logout URL for Browsers
 * This endpoint initializes a browser-based user logout flow and a URL which can be used to log out the user.

This endpoint is NOT INTENDED for API clients and only works
with browsers (Chrome, Firefox, ...). For API clients you can
call the `/self-service/logout/api` URL directly with the Session Token.

The URL is only valid for the currently signed in user. If no user is signed in, this endpoint returns
a 401 error.

When calling this endpoint from a backend, please ensure to properly forward the HTTP cookies.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return LogoutApiApiInitBrowserLogoutFlowRequestRequest
 */
func (a *LogoutApiService) InitBrowserLogoutFlowRequest(ctx context.Context) LogoutApiApiInitBrowserLogoutFlowRequestRequest {
	return LogoutApiApiInitBrowserLogoutFlowRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InitBrowserLogoutFlowResponse
 */
func (a *LogoutApiService) InitBrowserLogoutFlowRequestExecute(r LogoutApiApiInitBrowserLogoutFlowRequestRequest) (*InitBrowserLogoutFlowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *InitBrowserLogoutFlowResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogoutApiService.InitBrowserLogoutFlowRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/self-service/logout/browser"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.logoutChallenge != nil {
		localVarQueryParams.Add("logout_challenge", parameterToString(*r.logoutChallenge, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.cookie != nil {
		localVarHeaderParams["cookie"] = parameterToString(*r.cookie, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v JsonErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v JsonErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogoutApiApiSubmitLogoutFlowRequestRequest struct {
	ctx context.Context
	ApiService LogoutApi
	token *string
	returnTo *string
	logoutChallenge *string
}

func (r LogoutApiApiSubmitLogoutFlowRequestRequest) Token(token string) LogoutApiApiSubmitLogoutFlowRequestRequest {
	r.token = &token
	return r
}
func (r LogoutApiApiSubmitLogoutFlowRequestRequest) ReturnTo(returnTo string) LogoutApiApiSubmitLogoutFlowRequestRequest {
	r.returnTo = &returnTo
	return r
}
func (r LogoutApiApiSubmitLogoutFlowRequestRequest) LogoutChallenge(logoutChallenge string) LogoutApiApiSubmitLogoutFlowRequestRequest {
	r.logoutChallenge = &logoutChallenge
	return r
}

func (r LogoutApiApiSubmitLogoutFlowRequestRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubmitLogoutFlowRequestExecute(r)
}

/*
 * SubmitLogoutFlowRequest # Complete Self-Service Logout
 * This endpoint logs out an identity in a self-service manner.

If the `Accept` HTTP header is not set to `application/json`, the browser will be redirected (HTTP 303 See Other)
to the `return_to` parameter of the initial request or fall back to `urls.default_return_to`.

If the `Accept` HTTP header is set to `application/json`, a 204 No Content response
will be sent on successful logout instead.

This endpoint is NOT INTENDED for API clients and only works
with browsers (Chrome, Firefox, ...). For API clients you can
call the `/self-service/logout/api` URL directly with the Session Token.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return LogoutApiApiSubmitLogoutFlowRequestRequest
 */
func (a *LogoutApiService) SubmitLogoutFlowRequest(ctx context.Context) LogoutApiApiSubmitLogoutFlowRequestRequest {
	return LogoutApiApiSubmitLogoutFlowRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *LogoutApiService) SubmitLogoutFlowRequestExecute(r LogoutApiApiSubmitLogoutFlowRequestRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogoutApiService.SubmitLogoutFlowRequest")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/self-service/logout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	if r.returnTo != nil {
		localVarQueryParams.Add("return_to", parameterToString(*r.returnTo, ""))
	}
	if r.logoutChallenge != nil {
		localVarQueryParams.Add("logout_challenge", parameterToString(*r.logoutChallenge, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v JsonErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
