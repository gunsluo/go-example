// Package model contains the types for schema ...
package model

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"strconv"
	"strings"

	"github.com/graph-gophers/graphql-go"
	"github.com/lib/pq"
	"github.com/pkg/errors"
)

// Country represents a row from 'country'.
type Country struct {
	ID            int64          `json:"id" db:"id"`                         // id
	CountryName   string         `json:"country_name" db:"country_name"`     // country_name
	CountryLogo   sql.NullString `json:"country_logo" db:"country_logo"`     // country_logo
	CountryActive sql.NullBool   `json:"country_active" db:"country_active"` // country_active
	CountrySnum   sql.NullInt64  `json:"country_snum" db:"country_snum"`     // country_snum
	CountryNum    sql.NullInt64  `json:"country_num" db:"country_num"`       // country_num
	CountryBnum   sql.NullInt64  `json:"country_bnum" db:"country_bnum"`     // country_bnum
	CreatedDate   pq.NullTime    `json:"created_date" db:"created_date"`     // created_date
	ChangedDate   pq.NullTime    `json:"changed_date" db:"changed_date"`     // changed_date
	DeletedDate   pq.NullTime    `json:"deleted_date" db:"deleted_date"`     // deleted_date
	CountryCode   string         `json:"country_code" db:"country_code"`     // country_code

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Country exists in the database.
func (c *Country) Exists() bool {
	return c._exists
}

// Deleted provides information if the Country has been deleted from the database.
func (c *Country) Deleted() bool {
	return c._deleted
}

// Insert inserts the Country to the database.
func (c *Country) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if c._exists {
		return errors.New("insert failed: already exists")
	}

	params := make([]interface{}, 0, 10)
	fields := make([]string, 0, 10)
	retCols := "id"
	retVars := make([]interface{}, 0, 11)
	retVars = append(retVars, &c.ID)

	fields = append(fields, "country_name")
	params = append(params, c.CountryName)
	if c.CountryLogo.Valid {
		fields = append(fields, "country_logo")
		params = append(params, c.CountryLogo)
	} else {
		retCols += ", country_logo"
		retVars = append(retVars, &c.CountryLogo)
	}
	if c.CountryActive.Valid {
		fields = append(fields, "country_active")
		params = append(params, c.CountryActive)
	} else {
		retCols += ", country_active"
		retVars = append(retVars, &c.CountryActive)
	}
	if c.CountrySnum.Valid {
		fields = append(fields, "country_snum")
		params = append(params, c.CountrySnum)
	} else {
		retCols += ", country_snum"
		retVars = append(retVars, &c.CountrySnum)
	}
	if c.CountryNum.Valid {
		fields = append(fields, "country_num")
		params = append(params, c.CountryNum)
	} else {
		retCols += ", country_num"
		retVars = append(retVars, &c.CountryNum)
	}
	if c.CountryBnum.Valid {
		fields = append(fields, "country_bnum")
		params = append(params, c.CountryBnum)
	} else {
		retCols += ", country_bnum"
		retVars = append(retVars, &c.CountryBnum)
	}
	if c.CreatedDate.Valid {
		fields = append(fields, "created_date")
		params = append(params, c.CreatedDate)
	} else {
		retCols += ", created_date"
		retVars = append(retVars, &c.CreatedDate)
	}
	if c.ChangedDate.Valid {
		fields = append(fields, "changed_date")
		params = append(params, c.ChangedDate)
	} else {
		retCols += ", changed_date"
		retVars = append(retVars, &c.ChangedDate)
	}
	if c.DeletedDate.Valid {
		fields = append(fields, "deleted_date")
		params = append(params, c.DeletedDate)
	} else {
		retCols += ", deleted_date"
		retVars = append(retVars, &c.DeletedDate)
	}
	fields = append(fields, "country_code")
	params = append(params, c.CountryCode)

	if len(params) == 0 {
		// FIXME(jackie): maybe we should allow this?
		return errors.New("all fields are empty, unable to insert")
	}
	var placeHolders string
	for i := range params {
		placeHolders += "$" + strconv.Itoa(i+1)
		if i < len(params)-1 {
			placeHolders += ", "
		}
	}
	sqlstr := `INSERT INTO "country" (` +
		strings.Join(fields, ",") +
		`) VALUES (` + placeHolders +
		`) RETURNING ` + retCols

	err = db.QueryRow(sqlstr, params...).Scan(retVars...)
	if err != nil {
		return err
	}

	// set existence
	c._exists = true

	return nil
}

// Update updates the Country in the database.
func (c *Country) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !c._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if c._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query

	const sqlstr = `UPDATE "country" SET (` +
		`country_name, country_logo, country_active, country_snum, country_num, country_bnum, created_date, changed_date, deleted_date, country_code` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`) WHERE id = $11`

	// run query
	XOLog(sqlstr, c.CountryName, c.CountryLogo, c.CountryActive, c.CountrySnum, c.CountryNum, c.CountryBnum, c.CreatedDate, c.ChangedDate, c.DeletedDate, c.CountryCode, c.ID)
	_, err = db.Exec(sqlstr, c.CountryName, c.CountryLogo, c.CountryActive, c.CountrySnum, c.CountryNum, c.CountryBnum, c.CreatedDate, c.ChangedDate, c.DeletedDate, c.CountryCode, c.ID)
	return err
}

// Save saves the Country to the database.
func (c *Country) Save(db XODB) error {
	if c.Exists() {
		return c.Update(db)
	}

	return c.Insert(db)
}

// Upsert performs an upsert for Country.
//
// NOTE: PostgreSQL 9.5+ only
func (c *Country) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if c._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO "country" (` +
		`id, country_name, country_logo, country_active, country_snum, country_num, country_bnum, created_date, changed_date, deleted_date, country_code` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11` +
		`) ON CONFLICT (id) DO UPDATE SET (` +
		`id, country_name, country_logo, country_active, country_snum, country_num, country_bnum, created_date, changed_date, deleted_date, country_code` +
		`) = (` +
		`EXCLUDED.id, EXCLUDED.country_name, EXCLUDED.country_logo, EXCLUDED.country_active, EXCLUDED.country_snum, EXCLUDED.country_num, EXCLUDED.country_bnum, EXCLUDED.created_date, EXCLUDED.changed_date, EXCLUDED.deleted_date, EXCLUDED.country_code` +
		`)`

	// run query
	XOLog(sqlstr, c.ID, c.CountryName, c.CountryLogo, c.CountryActive, c.CountrySnum, c.CountryNum, c.CountryBnum, c.CreatedDate, c.ChangedDate, c.DeletedDate, c.CountryCode)
	_, err = db.Exec(sqlstr, c.ID, c.CountryName, c.CountryLogo, c.CountryActive, c.CountrySnum, c.CountryNum, c.CountryBnum, c.CreatedDate, c.ChangedDate, c.DeletedDate, c.CountryCode)
	if err != nil {
		return err
	}

	// set existence
	c._exists = true

	return nil
}

// Delete deletes the Country from the database.
func (c *Country) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !c._exists {
		return nil
	}

	// if deleted, bail
	if c._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM "country" WHERE id = $1`

	// run query
	XOLog(sqlstr, c.ID)
	_, err = db.Exec(sqlstr, c.ID)
	if err != nil {
		return err
	}

	// set deleted
	c._deleted = true

	return nil
}

// CountryFilter related to CountryQueryArguments
// struct field name contain table column name in Camel style and logic operator(lt, gt etc)
// only indexed column and special column defined in ExtraFilters declared in file extra_rules.yaml
type CountryFilter struct {
	Conjunction       *string // enum in "AND", "OR", nil(consider as single condition)
	CountryName       *string `json:"countryName"`        // equal to CountryName
	CountryNameLike   *string `json:"countryName_like"`   // LIKE
	CountryNameILike  *string `json:"countryName_ilike"`  // ILIKE case-insensitive
	CountryNameNLike  *string `json:"countryName_nlike"`  // NOT LIKE
	CountryNameNILike *string `json:"countryName_nilike"` // NOT ILIKE case-insensitive
	CountryCode       *string `json:"countryCode"`        // equal to CountryCode
	CountryCodeLike   *string `json:"countryCode_like"`   // LIKE
	CountryCodeILike  *string `json:"countryCode_ilike"`  // ILIKE case-insensitive
	CountryCodeNLike  *string `json:"countryCode_nlike"`  // NOT LIKE
	CountryCodeNILike *string `json:"countryCode_nilike"` // NOT ILIKE case-insensitive
}

// CountryQueryArguments composed by Cursor, CountryFilter and sql filter string
type CountryQueryArguments struct {
	Cursor
	Where *CountryFilter

	// non-export field
	filterArgs *filterArguments
}

// getCountryFilter return the sql filter
func getCountryFilter(filter *CountryFilter) (*filterArguments, error) {
	if filter == nil {
		return nil, nil
	}
	conjunction := ""
	conjCnt := 0
	var filterPairs []*filterPair
	if filter.Conjunction != nil {
		conjunction = *filter.Conjunction
		if _, ok := sqlConjunctionMap[conjunction]; !ok {
			return nil, fmt.Errorf("unsupported conjunction:%v", filter.Conjunction)
		}
	}
	if filter.CountryName != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "country_name", option: "=", value: *filter.CountryName})
	}
	if filter.CountryNameLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "country_name", option: "LIKE", value: *filter.CountryNameLike})
	}
	if filter.CountryNameILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "country_name", option: "ILIKE", value: *filter.CountryNameILike})
	}
	if filter.CountryNameNLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "country_name", option: "NOT LIKE", value: *filter.CountryNameNLike})
	}
	if filter.CountryNameNILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "country_name", option: "NOT ILIKE", value: *filter.CountryNameNILike})
	}
	if filter.CountryCode != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "country_code", option: "=", value: *filter.CountryCode})
	}
	if filter.CountryCodeLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "country_code", option: "LIKE", value: *filter.CountryCodeLike})
	}
	if filter.CountryCodeILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "country_code", option: "ILIKE", value: *filter.CountryCodeILike})
	}
	if filter.CountryCodeNLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "country_code", option: "NOT LIKE", value: *filter.CountryCodeNLike})
	}
	if filter.CountryCodeNILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "country_code", option: "NOT ILIKE", value: *filter.CountryCodeNILike})
	}
	if conjCnt == 0 {
		return nil, nil
	}
	if len(conjunction) > 0 && conjCnt < 2 {
		return nil, fmt.Errorf("invalid filter conjunction: %v need more than 2 parameter but have: %v", *filter.Conjunction, conjCnt)
	}
	if len(conjunction) == 0 && conjCnt != 1 {
		return nil, fmt.Errorf("multi field:%v should be connected by conjunction AND or OR", conjCnt)
	}
	filterArgs := &filterArguments{filterPairs: filterPairs, conjunction: conjunction, conjCnt: conjCnt}
	return filterArgs, nil
}

// ApplyCountryQueryArgsDefaults assigns default cursor values to non-nil fields.
func ApplyCountryQueryArgsDefaults(queryArgs *CountryQueryArguments) *CountryQueryArguments {
	if queryArgs == nil {
		queryArgs = &CountryQueryArguments{
			Cursor: DefaultCursor,
		}
		return queryArgs
	}
	if queryArgs.Offset == nil {
		queryArgs.Offset = DefaultCursor.Offset
	}
	if queryArgs.Limit == nil {
		queryArgs.Limit = DefaultCursor.Limit
	}
	if queryArgs.Index == nil {
		queryArgs.Index = DefaultCursor.Index
	}
	if queryArgs.Desc == nil {
		queryArgs.Desc = DefaultCursor.Desc
	}
	if queryArgs.Dead == nil {
		queryArgs.Dead = DefaultCursor.Dead
	}
	if queryArgs.After == nil {
		queryArgs.After = DefaultCursor.After
	}
	if queryArgs.First == nil {
		queryArgs.First = DefaultCursor.First
	}
	if queryArgs.Before == nil {
		queryArgs.Before = DefaultCursor.Before
	}
	if queryArgs.Last == nil {
		queryArgs.Last = DefaultCursor.Last
	}
	return queryArgs
}

// GetMostRecentCountry returns n most recent rows from 'country',
// ordered by "created_date" in descending order.
func GetMostRecentCountry(db XODB, n int) ([]*Country, error) {
	const sqlstr = `SELECT ` +
		`id, country_name, country_logo, country_active, country_snum, country_num, country_bnum, created_date, changed_date, deleted_date, country_code ` +
		`FROM "country" ` +
		`ORDER BY created_date DESC LIMIT $1`

	q, err := db.Query(sqlstr, n)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	var res []*Country
	for q.Next() {
		c := Country{}

		// scan
		err = q.Scan(&c.ID, &c.CountryName, &c.CountryLogo, &c.CountryActive, &c.CountrySnum, &c.CountryNum, &c.CountryBnum, &c.CreatedDate, &c.ChangedDate, &c.DeletedDate, &c.CountryCode)
		if err != nil {
			return nil, err
		}

		res = append(res, &c)
	}

	return res, nil
}

// GetMostRecentChangedCountry returns n most recent rows from 'country',
// ordered by "changed_date" in descending order.
func GetMostRecentChangedCountry(db XODB, n int) ([]*Country, error) {
	const sqlstr = `SELECT ` +
		`id, country_name, country_logo, country_active, country_snum, country_num, country_bnum, created_date, changed_date, deleted_date, country_code ` +
		`FROM "country" ` +
		`ORDER BY changed_date DESC LIMIT $1`

	q, err := db.Query(sqlstr, n)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	var res []*Country
	for q.Next() {
		c := Country{}

		// scan
		err = q.Scan(&c.ID, &c.CountryName, &c.CountryLogo, &c.CountryActive, &c.CountrySnum, &c.CountryNum, &c.CountryBnum, &c.CreatedDate, &c.ChangedDate, &c.DeletedDate, &c.CountryCode)
		if err != nil {
			return nil, err
		}

		res = append(res, &c)
	}

	return res, nil
}

// GetAllCountry returns all rows from 'country', based on the CountryQueryArguments.
// If the CountryQueryArguments is nil, it will use the default CountryQueryArguments instead.
func GetAllCountry(db XODB, queryArgs *CountryQueryArguments) ([]*Country, error) { // nolint: gocyclo
	queryArgs = ApplyCountryQueryArgsDefaults(queryArgs)
	if queryArgs.filterArgs == nil {
		filterArgs, err := getCountryFilter(queryArgs.Where)
		if err != nil {
			return nil, errors.Wrap(err, "unable to get Country filter")
		}
		queryArgs.filterArgs = filterArgs
	}

	desc := ""
	if *queryArgs.Desc {
		desc = "DESC"
	}

	dead := "NULL"
	if *queryArgs.Dead {
		dead = "NOT NULL"
	}

	var params []interface{}
	placeHolders := ""
	if queryArgs.filterArgs != nil {
		pls := make([]string, len(queryArgs.filterArgs.filterPairs))
		for i, pair := range queryArgs.filterArgs.filterPairs {
			pls[i] = fmt.Sprintf("%s %s $%d", pair.fieldName, pair.option, i+1)
			params = append(params, pair.value)
		}
		placeHolders = strings.Join(pls, " "+queryArgs.filterArgs.conjunction+" ")
		placeHolders = fmt.Sprintf("(%s) AND", placeHolders)
	}
	params = append(params, *queryArgs.Offset)
	offsetPos := len(params)

	params = append(params, *queryArgs.Limit)
	limitPos := len(params)
	var sqlstr = fmt.Sprintf(
		`SELECT %s FROM %s WHERE %s deleted_date IS %s ORDER BY %s %s OFFSET $%d LIMIT $%d`,
		`id, country_name, country_logo, country_active, country_snum, country_num, country_bnum, created_date, changed_date, deleted_date, country_code `,
		`"country"`,
		placeHolders,
		dead,
		"id",
		desc,
		offsetPos,
		limitPos)

	XOLog(sqlstr, params...)

	q, err := db.Query(sqlstr, params...)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	var res []*Country
	for q.Next() {
		c := Country{}

		// scan
		err = q.Scan(&c.ID, &c.CountryName, &c.CountryLogo, &c.CountryActive, &c.CountrySnum, &c.CountryNum, &c.CountryBnum, &c.CreatedDate, &c.ChangedDate, &c.DeletedDate, &c.CountryCode)
		if err != nil {
			return nil, err
		}

		res = append(res, &c)
	}

	return res, nil
}

// CountAllCountry returns a count of all rows from 'country'
func CountAllCountry(db XODB, queryArgs *CountryQueryArguments) (int, error) {
	queryArgs = ApplyCountryQueryArgsDefaults(queryArgs)
	if queryArgs.filterArgs == nil {
		filterArgs, err := getCountryFilter(queryArgs.Where)
		if err != nil {
			return 0, errors.Wrap(err, "unable to get Country filter")
		}
		queryArgs.filterArgs = filterArgs
	}

	dead := "NULL"
	if *queryArgs.Dead {
		dead = "NOT NULL"
	}

	var params []interface{}
	placeHolders := ""
	if queryArgs.filterArgs != nil {
		pls := make([]string, len(queryArgs.filterArgs.filterPairs))
		for i, pair := range queryArgs.filterArgs.filterPairs {
			pls[i] = fmt.Sprintf("%s %s $%d", pair.fieldName, pair.option, i+1)
			params = append(params, pair.value)
		}
		placeHolders = strings.Join(pls, " "+queryArgs.filterArgs.conjunction+" ")
		placeHolders = fmt.Sprintf("(%s) AND", placeHolders)
	}

	var err error
	var sqlstr = fmt.Sprintf(`SELECT count(*) from "country" WHERE %s deleted_date IS %s`, placeHolders, dead)
	XOLog(sqlstr)

	var count int
	err = db.QueryRow(sqlstr, params...).Scan(&count)
	if err != nil {
		return -1, err
	}
	return count, nil
}

const graphQLCountryQueries = `
	allCountries(where: CountryFilter, offset: Int, limit: Int): CountryConnection!
	countryByCountryCode(countryCode:String!):Country
	countryByCountryName(countryName:String!):Country
	countryByID(id:ID!):Country
`

const graphQLCountryMutations = `
	insertCountries(input: [InsertCountryInput!]!): [Country!]!
	updateCountries(input: [UpdateCountryInput!]!): [Country!]!
	deleteCountries(input: [DeleteCountryInput!]!): [ID!]!
`

func (RootResolver) AllCountries(ctx context.Context, args *CountryQueryArguments) (*CountryConnectionResolver, error) {
	verifier, ok := ctx.Value(VerifierCtx).(Verifier)
	if !ok {
		return nil, errors.New("verifier is not found in context")
	}
	if err := verifier.VerifyAC(ctx, "Countries", "GetAll", args); err != nil {
		return nil, errors.Wrap(err, "Countries:GetAll")
	}

	return AllCountries(ctx, args)
}

// CountryByCountryCode generated by country_country_code_key
func (RootResolver) CountryByCountryCode(ctx context.Context, args struct {
	CountryCode string
}) (*CountryResolver, error) {
	verifier, ok := ctx.Value(VerifierCtx).(Verifier)
	if !ok {
		return nil, errors.New("verifier is not found in context")
	}
	if err := verifier.VerifyAC(ctx, "Countries.CountryByCountryCode", "NonPrimaryKeyGet", args); err != nil {
		return nil, errors.Wrap(err, "Countries.CountryByCountryCode:NonPrimaryKeyGet")
	}

	return CountryByCountryCodeGraphQL(ctx, args)
}

// CountryByCountryName generated by country_country_name_key
func (RootResolver) CountryByCountryName(ctx context.Context, args struct {
	CountryName string
}) (*CountryResolver, error) {
	verifier, ok := ctx.Value(VerifierCtx).(Verifier)
	if !ok {
		return nil, errors.New("verifier is not found in context")
	}
	if err := verifier.VerifyAC(ctx, "Countries.CountryByCountryName", "NonPrimaryKeyGet", args); err != nil {
		return nil, errors.Wrap(err, "Countries.CountryByCountryName:NonPrimaryKeyGet")
	}

	return CountryByCountryNameGraphQL(ctx, args)
}

// CountryByID generated by country_pk
func (RootResolver) CountryByID(ctx context.Context, args struct {
	ID graphql.ID
}) (*CountryResolver, error) {
	verifier, ok := ctx.Value(VerifierCtx).(Verifier)
	if !ok {
		return nil, errors.New("verifier is not found in context")
	}
	if err := verifier.VerifyAC(ctx, "Countries", "Get", args); err != nil {
		return nil, errors.Wrap(err, "Countries:Get")
	}

	return CountryByIDGraphQL(ctx, args)
}

func (RootResolver) InsertCountries(ctx context.Context, args struct{ Input []InsertCountryInput }) ([]CountryResolver, error) {
	verifier, ok := ctx.Value(VerifierCtx).(Verifier)
	if !ok {
		return nil, errors.New("verifier is not found in context")
	}
	if err := verifier.VerifyAC(ctx, "Countries", "Insert", args); err != nil {
		return nil, errors.Wrap(err, "Countries:Insert")
	}

	return InsertCountryGraphQL(ctx, args.Input)
}

func (RootResolver) UpdateCountries(ctx context.Context, args struct{ Input []UpdateCountryInput }) ([]CountryResolver, error) {
	verifier, ok := ctx.Value(VerifierCtx).(Verifier)
	if !ok {
		return nil, errors.New("verifier is not found in context")
	}
	if err := verifier.VerifyAC(ctx, "Countries", "Update", args); err != nil {
		return nil, errors.Wrap(err, "Countries:Update")
	}

	return UpdateCountryGraphQL(ctx, args.Input)
}

func (RootResolver) DeleteCountries(ctx context.Context, args struct{ Input []DeleteCountryInput }) ([]graphql.ID, error) {
	verifier, ok := ctx.Value(VerifierCtx).(Verifier)
	if !ok {
		return nil, errors.New("verifier is not found in context")
	}
	if err := verifier.VerifyAC(ctx, "Countries", "Delete", args); err != nil {
		return nil, errors.Wrap(err, "Countries:Delete")
	}

	return DeleteCountryGraphQL(ctx, args.Input)
}

func GetCountryQueries() string {
	return graphQLCountryQueries
}

func GetCountryMutations() string {
	return graphQLCountryMutations
}

// GraphQLCountryTypes specifies the GraphQL types for Country
var GraphQLCountryTypes = `
	type Country {
		id: ID!
		countryName: String!
		countryLogo: String
		countryActive: Boolean
		countrySnum: String
		countryNum: String
		countryBnum: String
		createdDate: Time
		changedDate: Time
		deletedDate: Time
		countryCode: String!
	}

	type CountryConnection {
		pageInfo: PageInfo!
		edges: [CountryEdge]
		totalCount: Int
		countries: [Country]
	}

	type CountryEdge {
		node: Country
		cursor: ID!
	}

	input CountryFilter {
		conjunction: FilterConjunction
		countryName: String
		countryName_like: String // LIKE
		countryName_ilike: String // LIKE case insensitive
		countryName_nlike: String	// NOT LIKE
		countryName_nilike: String // NOT LIKE case insensitive
		countryCode: String
		countryCode_like: String // LIKE
		countryCode_ilike: String // LIKE case insensitive
		countryCode_nlike: String	// NOT LIKE
		countryCode_nilike: String // NOT LIKE case insensitive
	}

	input InsertCountryInput {
		countryName: String!
		countryLogo: String
		countryActive: Boolean
		countrySnum: String
		countryNum: String
		countryBnum: String
		createdDate: Time
		changedDate: Time
		deletedDate: Time
		countryCode: String!
	}

	input UpdateCountryInput {
		id: ID!
		countryName: String
		countryLogo: String
		countryActive: Boolean
		countrySnum: String
		countryNum: String
		countryBnum: String
		createdDate: Time
		changedDate: Time
		deletedDate: Time
		countryCode: String
        nullFields: [String!]
	}

	input DeleteCountryInput {
		id: ID!
	}
`

// GraphQLCountryAPIs specifies the GraphQL APIs for Country
var GraphQLCountryAPIs = map[string]string{
	"Countries":                      "This is a graphQL resource Countries, have GetAll, Get, Insert, Update, Delete actions.",
	"Countries.CountryByCountryCode": "This is a graphQL resource Countries.CountryByCountryCode, only have NonPrimaryKeyGet action.",
	"Countries.CountryByCountryName": "This is a graphQL resource Countries.CountryByCountryName, only have NonPrimaryKeyGet action.",
}

// CountryResolver defines the GraphQL resolver for 'Country'.
type CountryResolver struct{ node *Country }

func NewCountryResolver(node *Country) *CountryResolver {
	return &CountryResolver{node: node}
}
func (r CountryResolver) ID() graphql.ID             { return graphql.ID(strconv.FormatInt(r.node.ID, 10)) }
func (r CountryResolver) CountryName() string        { return r.node.CountryName }
func (r CountryResolver) CountryLogo() *string       { return PointerString(r.node.CountryLogo) }
func (r CountryResolver) CountryActive() *bool       { return PointerBool(r.node.CountryActive) }
func (r CountryResolver) CountrySnum() *string       { return PointerStringSqlInt64(r.node.CountrySnum) }
func (r CountryResolver) CountryNum() *string        { return PointerStringSqlInt64(r.node.CountryNum) }
func (r CountryResolver) CountryBnum() *string       { return PointerStringSqlInt64(r.node.CountryBnum) }
func (r CountryResolver) CreatedDate() *graphql.Time { return PointerGqlTime(r.node.CreatedDate) }
func (r CountryResolver) ChangedDate() *graphql.Time { return PointerGqlTime(r.node.ChangedDate) }
func (r CountryResolver) DeletedDate() *graphql.Time { return PointerGqlTime(r.node.DeletedDate) }
func (r CountryResolver) CountryCode() string        { return r.node.CountryCode }

// CountryConnectionResolver defines a GraphQL resolver for CountryConnection
type CountryConnectionResolver struct {
	data  []*Country
	count int32
}

func NewCountryConnectionResolver(data []*Country, count int) *CountryConnectionResolver {
	return &CountryConnectionResolver{
		data:  data,
		count: int32(count),
	}
}

// PageInfo returns PageInfo
func (r CountryConnectionResolver) PageInfo() *PageInfoResolver {
	if len(r.data) == 0 {
		return nil
	}

	return &PageInfoResolver{
		startCursor:     encodeCursor("Country", int(r.data[0].ID)),
		endCursor:       encodeCursor("Country", int(r.data[len(r.data)-1].ID)),
		hasNextPage:     false, // TODO
		hasPreviousPage: false, // TODO
	}
}

// Edges returns standard GraphQL edges
func (r CountryConnectionResolver) Edges() *[]*CountryEdgeResolver {
	edges := make([]*CountryEdgeResolver, len(r.data))

	for i := range r.data {
		edges[i] = &CountryEdgeResolver{node: r.data[i]}
	}
	return &edges
}

// TotalCount returns total count
func (r CountryConnectionResolver) TotalCount() *int32 {
	return &r.count
}

// Countries returns the list of Country
func (r CountryConnectionResolver) Countries() *[]*CountryResolver {
	data := make([]*CountryResolver, len(r.data))
	for i := range r.data {
		data[i] = &CountryResolver{r.data[i]}
	}
	return &data
}

// CountryEdgeResolver defines the Country edge
type CountryEdgeResolver struct {
	node *Country
}

// Node returns the Country node
func (r CountryEdgeResolver) Node() *CountryResolver {
	return &CountryResolver{r.node}
}

// Cursor returns the cursor
func (r CountryEdgeResolver) Cursor() graphql.ID {
	return encodeCursor("Country", int(r.node.ID))
}

// InsertCountryInput defines the insert Country mutation input
type InsertCountryInput struct {
	CountryName   string
	CountryLogo   *string
	CountryActive *bool
	CountrySnum   *string
	CountryNum    *string
	CountryBnum   *string
	CreatedDate   *graphql.Time
	ChangedDate   *graphql.Time
	DeletedDate   *graphql.Time
	CountryCode   string
}

// UpdateCountryInput defines the update Country mutation input
type UpdateCountryInput struct {
	ID            graphql.ID
	CountryName   *string
	CountryLogo   *string
	CountryActive *bool
	CountrySnum   *string
	CountryNum    *string
	CountryBnum   *string
	CreatedDate   *graphql.Time
	ChangedDate   *graphql.Time
	DeletedDate   *graphql.Time
	CountryCode   *string
	updateArguments
}

// DeleteCountryInput defines the delete Country mutation input
type DeleteCountryInput struct {
	ID graphql.ID
}

// AllCountries is the GraphQL end point for GetAllCountry
func AllCountries(ctx context.Context, queryArgs *CountryQueryArguments) (*CountryConnectionResolver, error) { // nolint: gocyclo
	db, ok := ctx.Value(DBCtx).(XODB)
	if !ok {
		return nil, errors.New("db is not found in context")
	}

	if queryArgs != nil && (queryArgs.After != nil || queryArgs.First != nil || queryArgs.Before != nil || queryArgs.Last != nil) {
		return nil, errors.New("not implemented yet, use offset + limit for pagination")
	}

	queryArgs = ApplyCountryQueryArgsDefaults(queryArgs)

	filterArgs, err := getCountryFilter(queryArgs.Where)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get Country filter")
	}
	queryArgs.filterArgs = filterArgs

	allCountry, err := GetAllCountry(db, queryArgs)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get Country")
	}

	count, err := CountAllCountry(db, queryArgs)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get count")
	}

	return &CountryConnectionResolver{
		data:  allCountry,
		count: int32(count),
	}, nil
}

// InsertCountryGraphQL is the GraphQL end point for InsertCountry
func InsertCountryGraphQL(ctx context.Context, items []InsertCountryInput) ([]CountryResolver, error) {
	db, ok := ctx.Value(DBCtx).(XODB)
	if !ok {
		return nil, errors.New("db is not found in context")
	}
	results := make([]CountryResolver, len(items))
	for i := range items {
		input := items[i]

		f1 := input.CountryName
		f2 := StringPointer(input.CountryLogo)
		f3 := BoolPointer(input.CountryActive)
		var f4 sql.NullInt64
		if input.CountrySnum != nil {
			n, err := strconv.ParseInt(*input.CountrySnum, 10, 0)
			if err != nil {
				return nil, errors.New("CountrySnum must be an integer")
			}
			f4 = sql.NullInt64{Int64: n, Valid: true}
		}
		var f5 sql.NullInt64
		if input.CountryNum != nil {
			n, err := strconv.ParseInt(*input.CountryNum, 10, 0)
			if err != nil {
				return nil, errors.New("CountryNum must be an integer")
			}
			f5 = sql.NullInt64{Int64: n, Valid: true}
		}
		var f6 sql.NullInt64
		if input.CountryBnum != nil {
			n, err := strconv.ParseInt(*input.CountryBnum, 10, 0)
			if err != nil {
				return nil, errors.New("CountryBnum must be an integer")
			}
			f6 = sql.NullInt64{Int64: n, Valid: true}
		}
		f7 := TimeGqlPointer(input.CreatedDate)
		f8 := TimeGqlPointer(input.ChangedDate)
		f9 := TimeGqlPointer(input.DeletedDate)
		f10 := input.CountryCode
		node := &Country{
			CountryName:   f1,
			CountryLogo:   f2,
			CountryActive: f3,
			CountrySnum:   f4,
			CountryNum:    f5,
			CountryBnum:   f6,
			CreatedDate:   f7,
			ChangedDate:   f8,
			DeletedDate:   f9,
			CountryCode:   f10,
		}
		if err := node.Insert(db); err != nil {
			return nil, errors.Wrap(err, "unable to insert Country")
		}
		results[i] = CountryResolver{node: node}
	}
	return results, nil
}

// UpdateCountryGraphQL is the GraphQL end point for UpdateCountry
func UpdateCountryGraphQL(ctx context.Context, items []UpdateCountryInput) ([]CountryResolver, error) {
	db, ok := ctx.Value(DBCtx).(XODB)
	if !ok {
		return nil, errors.New("db is not found in context")
	}
	results := make([]CountryResolver, len(items))
	for i := range items {
		input := items[i]
		id, err := strconv.ParseInt(string(input.ID), 10, 64)
		if err != nil {
			return nil, errors.New("ID must be an integer")
		}
		node := &Country{ID: id}
		fields := make([]string, 0, 10)
		params := make([]interface{}, 0, 10)
		retCols := make([]string, 0, 10)
		retVars := make([]interface{}, 0, 10)
		if isNullFields(input.NullFields, "country_name") {
			return nil, errors.New("couldn't set country_name to null")
		}
		if input.CountryName != nil {
			fields = append(fields, "country_name")
			params = append(params, *input.CountryName)
			node.CountryName = *input.CountryName
		} else {
			retCols = append(retCols, "country_name")
			retVars = append(retVars, &node.CountryName)
		}
		if isNullFields(input.NullFields, "country_logo") {
			fields = append(fields, "country_logo")
			params = append(params, sql.NullString{})
			node.CountryLogo = sql.NullString{}
		} else {
			if input.CountryLogo != nil {
				fields = append(fields, "country_logo")
				params = append(params, *input.CountryLogo)
				node.CountryLogo = sql.NullString{String: *input.CountryLogo, Valid: true}
			} else {
				retCols = append(retCols, "country_logo")
				retVars = append(retVars, &node.CountryLogo)
			}
		}
		if isNullFields(input.NullFields, "country_active") {
			fields = append(fields, "country_active")
			params = append(params, sql.NullBool{})
			node.CountryActive = sql.NullBool{}
		} else {
			if input.CountryActive != nil {
				fields = append(fields, "country_active")
				params = append(params, *input.CountryActive)
				node.CountryActive = sql.NullBool{Bool: *input.CountryActive, Valid: true}
			} else {
				retCols = append(retCols, "country_active")
				retVars = append(retVars, &node.CountryActive)
			}
		}
		if isNullFields(input.NullFields, "country_snum") {
			fields = append(fields, "country_snum")
			params = append(params, sql.NullInt64{})
			node.CountrySnum = sql.NullInt64{}
		} else {
			if input.CountrySnum != nil {
				fields = append(fields, "country_snum")
				params = append(params, *input.CountrySnum)
				if n, err := strconv.ParseInt(*input.CountrySnum, 10, 64); err != nil {
					return nil, errors.New("CountrySnum must be an integer")
				} else {
					node.CountrySnum = sql.NullInt64{Int64: n, Valid: true}
				}
			} else {
				retCols = append(retCols, "country_snum")
				retVars = append(retVars, &node.CountrySnum)
			}
		}
		if isNullFields(input.NullFields, "country_num") {
			fields = append(fields, "country_num")
			params = append(params, sql.NullInt64{})
			node.CountryNum = sql.NullInt64{}
		} else {
			if input.CountryNum != nil {
				fields = append(fields, "country_num")
				params = append(params, *input.CountryNum)
				if n, err := strconv.ParseInt(*input.CountryNum, 10, 64); err != nil {
					return nil, errors.New("CountryNum must be an integer")
				} else {
					node.CountryNum = sql.NullInt64{Int64: n, Valid: true}
				}
			} else {
				retCols = append(retCols, "country_num")
				retVars = append(retVars, &node.CountryNum)
			}
		}
		if isNullFields(input.NullFields, "country_bnum") {
			fields = append(fields, "country_bnum")
			params = append(params, sql.NullInt64{})
			node.CountryBnum = sql.NullInt64{}
		} else {
			if input.CountryBnum != nil {
				fields = append(fields, "country_bnum")
				params = append(params, *input.CountryBnum)
				if n, err := strconv.ParseInt(*input.CountryBnum, 10, 64); err != nil {
					return nil, errors.New("CountryBnum must be an integer")
				} else {
					node.CountryBnum = sql.NullInt64{Int64: n, Valid: true}
				}
			} else {
				retCols = append(retCols, "country_bnum")
				retVars = append(retVars, &node.CountryBnum)
			}
		}
		if isNullFields(input.NullFields, "created_date") {
			fields = append(fields, "created_date")
			params = append(params, pq.NullTime{})
			node.CreatedDate = pq.NullTime{}
		} else {
			if input.CreatedDate != nil {
				fields = append(fields, "created_date")
				params = append(params, input.CreatedDate.Time)
				node.CreatedDate = pq.NullTime{Time: input.CreatedDate.Time, Valid: true}
			} else {
				retCols = append(retCols, "created_date")
				retVars = append(retVars, &node.CreatedDate)
			}
		}
		if isNullFields(input.NullFields, "changed_date") {
			fields = append(fields, "changed_date")
			params = append(params, pq.NullTime{})
			node.ChangedDate = pq.NullTime{}
		} else {
			if input.ChangedDate != nil {
				fields = append(fields, "changed_date")
				params = append(params, input.ChangedDate.Time)
				node.ChangedDate = pq.NullTime{Time: input.ChangedDate.Time, Valid: true}
			} else {
				retCols = append(retCols, "changed_date")
				retVars = append(retVars, &node.ChangedDate)
			}
		}
		if isNullFields(input.NullFields, "deleted_date") {
			fields = append(fields, "deleted_date")
			params = append(params, pq.NullTime{})
			node.DeletedDate = pq.NullTime{}
		} else {
			if input.DeletedDate != nil {
				fields = append(fields, "deleted_date")
				params = append(params, input.DeletedDate.Time)
				node.DeletedDate = pq.NullTime{Time: input.DeletedDate.Time, Valid: true}
			} else {
				retCols = append(retCols, "deleted_date")
				retVars = append(retVars, &node.DeletedDate)
			}
		}
		if isNullFields(input.NullFields, "country_code") {
			return nil, errors.New("couldn't set country_code to null")
		}
		if input.CountryCode != nil {
			fields = append(fields, "country_code")
			params = append(params, *input.CountryCode)
			node.CountryCode = *input.CountryCode
		} else {
			retCols = append(retCols, "country_code")
			retVars = append(retVars, &node.CountryCode)
		}
		if len(params) == 0 {
			return nil, errors.New("all fields are empty, unable to update")
		}
		var placeHolders string
		for i := range params {
			placeHolders += "$" + strconv.Itoa(i+1)
			if i < len(params)-1 {
				placeHolders += ", "
			}
		}
		params = append(params, id)
		var sqlstr string
		if len(fields) == 1 {
			sqlstr = `UPDATE "country" SET ` +
				strings.Join(fields, ",") +
				` = ` + placeHolders +
				` WHERE id = $` + strconv.Itoa(len(params)) +
				` RETURNING ` + strings.Join(retCols, ", ")
		} else {
			sqlstr = `UPDATE "country" SET (` +
				strings.Join(fields, ",") +
				`) = (` + placeHolders +
				`) WHERE id = $` + strconv.Itoa(len(params)) +
				` RETURNING ` + strings.Join(retCols, ", ")
		}
		if err := db.QueryRow(sqlstr, params...).Scan(retVars...); err != nil {
			return nil, err
		}

		results[i] = CountryResolver{node: node}
	}
	return results, nil
}

// DeleteCountryGraphQL is the GraphQL end point for DeleteCountry
func DeleteCountryGraphQL(ctx context.Context, items []DeleteCountryInput) ([]graphql.ID, error) {
	db, ok := ctx.Value(DBCtx).(XODB)
	if !ok {
		return nil, errors.New("db is not found in context")
	}
	// sql query
	const sqlstr = `DELETE FROM "country" WHERE id = $1`

	results := make([]graphql.ID, len(items))

	for i := range items {
		input := items[i]

		id, err := strconv.ParseInt(string(input.ID), 10, 0)
		if err != nil {
			return nil, errors.New("ID must be an integer")
		}

		XOLog(sqlstr, id)
		_, err = db.Exec(sqlstr, id)
		if err != nil {
			return nil, err
		}
		results[i] = input.ID
	}
	return results, nil
}

// CountryByCountryCode retrieves a row from 'country' as a Country.
//
// Generated from index 'country_country_code_key'.
func CountryByCountryCode(db XODB, countryCode string) (*Country, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, country_name, country_logo, country_active, country_snum, country_num, country_bnum, created_date, changed_date, deleted_date, country_code ` +
		`FROM "country" ` +
		`WHERE country_code = $1`

	// run query
	XOLog(sqlstr, countryCode)
	c := Country{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, countryCode).Scan(&c.ID, &c.CountryName, &c.CountryLogo, &c.CountryActive, &c.CountrySnum, &c.CountryNum, &c.CountryBnum, &c.CreatedDate, &c.ChangedDate, &c.DeletedDate, &c.CountryCode)
	if err != nil {
		return nil, err
	}

	return &c, nil
}

// CountryByCountryCodeGraphQL retrieves a row from 'country' as a Country.
//
// Generated from index 'country_country_code_key'.
func CountryByCountryCodeGraphQL(ctx context.Context, args struct {
	CountryCode string
}) (*CountryResolver, error) {
	db, ok := ctx.Value(DBCtx).(XODB)
	if !(ok) {
		return nil, errors.New("db is not found in context")
	}

	arg0 := args.CountryCode

	data, err := CountryByCountryCode(db, arg0)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get country")
	}

	return &CountryResolver{node: data}, nil

}

// CountryByCountryName retrieves a row from 'country' as a Country.
//
// Generated from index 'country_country_name_key'.
func CountryByCountryName(db XODB, countryName string) (*Country, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, country_name, country_logo, country_active, country_snum, country_num, country_bnum, created_date, changed_date, deleted_date, country_code ` +
		`FROM "country" ` +
		`WHERE country_name = $1`

	// run query
	XOLog(sqlstr, countryName)
	c := Country{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, countryName).Scan(&c.ID, &c.CountryName, &c.CountryLogo, &c.CountryActive, &c.CountrySnum, &c.CountryNum, &c.CountryBnum, &c.CreatedDate, &c.ChangedDate, &c.DeletedDate, &c.CountryCode)
	if err != nil {
		return nil, err
	}

	return &c, nil
}

// CountryByCountryNameGraphQL retrieves a row from 'country' as a Country.
//
// Generated from index 'country_country_name_key'.
func CountryByCountryNameGraphQL(ctx context.Context, args struct {
	CountryName string
}) (*CountryResolver, error) {
	db, ok := ctx.Value(DBCtx).(XODB)
	if !(ok) {
		return nil, errors.New("db is not found in context")
	}

	arg0 := args.CountryName

	data, err := CountryByCountryName(db, arg0)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get country")
	}

	return &CountryResolver{node: data}, nil

}

// CountryByID retrieves a row from 'country' as a Country.
//
// Generated from index 'country_pk'.
func CountryByID(db XODB, id int64) (*Country, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, country_name, country_logo, country_active, country_snum, country_num, country_bnum, created_date, changed_date, deleted_date, country_code ` +
		`FROM "country" ` +
		`WHERE id = $1`

	// run query
	XOLog(sqlstr, id)
	c := Country{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&c.ID, &c.CountryName, &c.CountryLogo, &c.CountryActive, &c.CountrySnum, &c.CountryNum, &c.CountryBnum, &c.CreatedDate, &c.ChangedDate, &c.DeletedDate, &c.CountryCode)
	if err != nil {
		return nil, err
	}

	return &c, nil
}

// CountryByIDGraphQL retrieves a row from 'country' as a Country.
//
// Generated from index 'country_pk'.
func CountryByIDGraphQL(ctx context.Context, args struct {
	ID graphql.ID
}) (*CountryResolver, error) {
	db, ok := ctx.Value(DBCtx).(XODB)
	if !(ok) {
		return nil, errors.New("db is not found in context")
	}

	arg0, err := strconv.ParseInt(string(args.ID), 10, 64)
	if err != nil {
		return nil, errors.Wrap(err, "ID should be int64")
	}

	data, err := CountryByID(db, arg0)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get country")
	}

	return &CountryResolver{node: data}, nil

}
