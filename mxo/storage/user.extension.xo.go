// Package storage contains the types for schema.
package storage

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"strconv"

	"github.com/graph-gophers/graphql-go"
	"github.com/pkg/errors"
)

// UserQueryArguments composed by Cursor, UserFilter and sql filter string
type UserQueryArguments struct {
	Cursor
}

// ApplyUserQueryArgsDefaults assigns default cursor values to non-nil fields.
func ApplyUserQueryArgsDefaults(queryArgs *UserQueryArguments) *UserQueryArguments {
	if queryArgs == nil {
		queryArgs = &UserQueryArguments{
			Cursor: DefaultCursor,
		}
		return queryArgs
	}
	if queryArgs.Offset == nil {
		queryArgs.Offset = DefaultCursor.Offset
	}
	if queryArgs.Limit == nil {
		queryArgs.Limit = DefaultCursor.Limit
	}
	if queryArgs.OrderBy == nil {
		queryArgs.OrderBy = DefaultCursor.OrderBy
	}
	if queryArgs.Desc == nil {
		queryArgs.Desc = DefaultCursor.Desc
	}
	if queryArgs.Dead == nil {
		queryArgs.Dead = DefaultCursor.Dead
	}
	if queryArgs.After == nil {
		queryArgs.After = DefaultCursor.After
	}
	if queryArgs.First == nil {
		queryArgs.First = DefaultCursor.First
	}
	if queryArgs.Before == nil {
		queryArgs.Before = DefaultCursor.Before
	}
	if queryArgs.Last == nil {
		queryArgs.Last = DefaultCursor.Last
	}
	return queryArgs
}

const graphQLUserQueries = `
	allUsers(offset: Int, limit: Int, orderBy: String, desc: Boolean): UserConnection!
	userByID(id:ID!):User
`

const graphQLUserMutations = `
	insertUsers(input: [InsertUserInput!]!): [User!]!
	updateUsers(input: [UpdateUserInput!]!): [User!]!
	deleteUsers(input: [DeleteUserInput!]!): [ID!]!
`

var graphQLUserTypes = `
	type User {
		id: ID!
		subject: Account
		name: String
		createdDate: Time
		changedDate: Time
		deletedDate: Time
	}

	type UserConnection {
		pageInfo: PageInfo!
		edges: [UserEdge]
		totalCount: Int
		users: [User]
	}

	type UserEdge {
		node: User
		cursor: ID!
	}


	input InsertUserInput {
		subject: String!
		name: String
		createdDate: Time
		changedDate: Time
		deletedDate: Time
	}

	input UpdateUserInput {
		id: ID!
		subject: String
		name: String
		createdDate: Time
		changedDate: Time
		deletedDate: Time
		_deletions: [String!]
	}

	input DeleteUserInput {
		id: ID!
	}
`

// GetUserQueries specifies the GraphQL queries for User
func (r *RootResolver) GetUserQueries() string {
	return graphQLUserQueries
}

// GetUserMutations specifies the GraphQL mutations for User
func (r *RootResolver) GetUserMutations() string {
	return graphQLUserMutations
}

// GetUserTypes specifies the GraphQL types for User
func (r *RootResolver) GetUserTypes() string {
	return graphQLUserTypes
}

// UserResolver defines the GraphQL resolver for 'User'.
type UserResolver struct {
	ext  resolverExtensions
	node *User
}

// UserResolver defines a GraphQL resolver for User
func NewUserResolver(node *User, ext resolverExtensions) *UserResolver {
	return &UserResolver{ext: ext, node: node}
}

// Node get node for UserResolver
func (r UserResolver) Node() *User {
	return r.node
}
func (r UserResolver) ID() graphql.ID { return graphql.ID(strconv.Itoa(r.node.ID)) }
func (r UserResolver) Subject(ctx context.Context) (*AccountResolver, error) {
	subject := r.node.Subject
	node, err := r.ext.storage.AccountBySubject(r.ext.db, subject)
	if err != nil {
		return nil, errors.Wrap(err, "unable to retrieve Subject")
	}
	return NewAccountResolver(node, r.ext), nil
}
func (r UserResolver) Name() *string              { return PointerString(r.node.Name) }
func (r UserResolver) CreatedDate() *graphql.Time { return PointerGqlTime(r.node.CreatedDate) }
func (r UserResolver) ChangedDate() *graphql.Time { return PointerGqlTime(r.node.ChangedDate) }
func (r UserResolver) DeletedDate() *graphql.Time { return PointerGqlTime(r.node.DeletedDate) }

// UserByID generated by user_pk
func (r *RootResolver) UserByID(ctx context.Context, args struct {
	ID graphql.ID
}) (*UserResolver, error) {

	res, err := r.innerUserByIDGraphQL(ctx, args)

	// event record
	if r.ext.recorder != nil {
		if err := r.ext.recorder.RecordEvent(ctx, "Users", "Get", res); err != nil {
			r.ext.logger.Warnf("unable to record event, resource:Users, action:Get, err:%v", err)
		}
	}
	return res, err
}

// innerUserByIDGraphQL retrieves a row from '"public"."user"' as a User.
// Generated from index 'user_pk'.
func (r *RootResolver) innerUserByIDGraphQL(ctx context.Context, args struct {
	ID graphql.ID
}) (*UserResolver, error) {

	arg0, err := strconv.Atoi(string(args.ID))
	if err != nil {
		return nil, errors.Wrap(err, `ID should be integer`)
	}

	data, err := r.ext.storage.UserByID(r.ext.db, arg0)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, errors.Errorf(`user [`+"%v"+`] not found`, arg0)
		}
		return nil, errors.Wrap(err, `unable to get "public"."user"`)
	}

	return NewUserResolver(data, r.ext), nil

}

// UserConnectionResolver defines a GraphQL resolver for UserConnection
type UserConnectionResolver struct {
	ext resolverExtensions

	data  []*User
	count int32
}

// NewUserConnectionResolver return a GraphQL resolver for UserConnection
func NewUserConnectionResolver(data []*User, count int, ext resolverExtensions) *UserConnectionResolver {
	return &UserConnectionResolver{
		ext:   ext,
		data:  data,
		count: int32(count),
	}
}

// PageInfo returns PageInfo
func (r UserConnectionResolver) PageInfo() *PageInfoResolver {
	if len(r.data) == 0 {
		return &PageInfoResolver{}
	}

	return &PageInfoResolver{
		startCursor:     encodeCursor("User", int(r.data[0].ID)),
		endCursor:       encodeCursor("User", int(r.data[len(r.data)-1].ID)),
		hasNextPage:     false, // TODO
		hasPreviousPage: false, // TODO
	}
}

// Edges returns standard GraphQL edges
func (r UserConnectionResolver) Edges() *[]*UserEdgeResolver {
	edges := make([]*UserEdgeResolver, len(r.data))

	for i := range r.data {
		edges[i] = NewUserEdgeResolver(r.data[i], r.ext)
	}
	return &edges
}

// TotalCount returns total count
func (r UserConnectionResolver) TotalCount() *int32 {
	return &r.count
}

// Users returns the list of User
func (r UserConnectionResolver) Users() *[]*UserResolver {
	data := make([]*UserResolver, len(r.data))
	for i := range r.data {
		data[i] = NewUserResolver(r.data[i], r.ext)
	}
	return &data
}

// UserEdgeResolver defines the User edge
type UserEdgeResolver struct {
	ext  resolverExtensions
	node *User
}

// NewUserEdgeResolver return a GraphQL resolver for UserEdgeResolver
func NewUserEdgeResolver(node *User, ext resolverExtensions) *UserEdgeResolver {
	return &UserEdgeResolver{
		ext:  ext,
		node: node,
	}
}

// Node returns the User node
func (r UserEdgeResolver) Node() *UserResolver {
	return NewUserResolver(r.node, r.ext)
}

// Cursor returns the cursor
func (r UserEdgeResolver) Cursor() graphql.ID {
	return encodeCursor("User", int(r.node.ID))
}

// InsertUserInput defines the insert User mutation input
type InsertUserInput struct {
	Subject     string
	Name        *string
	CreatedDate *graphql.Time
	ChangedDate *graphql.Time
	DeletedDate *graphql.Time
}

// UpdateUserInput defines the update User mutation input
type UpdateUserInput struct {
	ID          graphql.ID
	Subject     *string
	Name        *string
	CreatedDate *graphql.Time
	ChangedDate *graphql.Time
	DeletedDate *graphql.Time
	updateArguments
}

// DeleteUserInput defines the delete User mutation input
type DeleteUserInput struct {
	ID graphql.ID
}

// AllUsers is a graphQL endpoint of AllUsers
func (r *RootResolver) AllUsers(ctx context.Context, args *UserQueryArguments) (*UserConnectionResolver, error) {

	res, err := r.allUsers(ctx, args)

	// event record
	if r.ext.recorder != nil {
		if err := r.ext.recorder.RecordEvent(ctx, "Users", "GetAll", res); err != nil {
			r.ext.logger.Warnf("unable to record event, resource:Users, action:GetAll, err:%v", err)
		}
	}
	return res, err
}

func (r *RootResolver) allUsers(ctx context.Context, queryArgs *UserQueryArguments) (*UserConnectionResolver, error) {
	if queryArgs != nil && (queryArgs.After != nil || queryArgs.First != nil || queryArgs.Before != nil || queryArgs.Last != nil) {
		return nil, errors.New("not implemented yet, use offset + limit for pagination")
	}

	queryArgs = ApplyUserQueryArgsDefaults(queryArgs)

	allUser, err := r.ext.storage.GetAllUser(r.ext.db, queryArgs)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get User")
	}

	count, err := r.ext.storage.CountAllUser(r.ext.db, queryArgs)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get count")
	}

	return &UserConnectionResolver{
		ext:   r.ext,
		data:  allUser,
		count: int32(count),
	}, nil
}

// InsertUsers is a graphQL endpoint of InsertUsers
func (r *RootResolver) InsertUsers(ctx context.Context, args struct{ Input []InsertUserInput }) ([]UserResolver, error) {

	res, err := r.insertUserGraphQL(ctx, args.Input)

	// event record
	if r.ext.recorder != nil {
		if err := r.ext.recorder.RecordEvent(ctx, "Users", "Insert", res); err != nil {
			r.ext.logger.Warnf("unable to record event, resource:Users, action:Insert, err:%v", err)
		}
	}
	return res, err
}

func (r *RootResolver) insertUserGraphQL(ctx context.Context, items []InsertUserInput) ([]UserResolver, error) {
	results := make([]UserResolver, len(items))
	for i := range items {
		input := items[i]

		f1 := input.Subject
		f2 := StringPointer(input.Name)
		f3 := TimeGqlPointer(input.CreatedDate)
		f4 := TimeGqlPointer(input.ChangedDate)
		f5 := TimeGqlPointer(input.DeletedDate)
		node := &User{
			Subject:     f1,
			Name:        f2,
			CreatedDate: f3,
			ChangedDate: f4,
			DeletedDate: f5,
		}
		if err := r.ext.storage.InsertUserByFields(r.ext.db, node); err != nil {
			return nil, errors.Wrap(err, "unable to insert User")
		}
		results[i] = UserResolver{ext: r.ext, node: node}
	}
	return results, nil
}

// UpdateUserGraphQL is the GraphQL end point for UpdateUser
func (r *RootResolver) UpdateUsers(ctx context.Context, args struct{ Input []UpdateUserInput }) ([]UserResolver, error) {

	res, err := r.updateUserGraphQL(ctx, args.Input)

	// event record
	if r.ext.recorder != nil {
		if err := r.ext.recorder.RecordEvent(ctx, "Users", "Update", res); err != nil {
			r.ext.logger.Warnf("unable to record event, resource:Users, action:Update, err:%v", err)
		}
	}
	return res, err
}

func (r *RootResolver) updateUserGraphQL(ctx context.Context, items []UpdateUserInput) ([]UserResolver, error) {
	results := make([]UserResolver, len(items))
	for i := range items {
		input := items[i]
		id, err := strconv.Atoi(string(input.ID))
		if err != nil {
			return nil, errors.New("ID must be an integer")
		}

		node := &User{ID: id}
		fields := make([]string, 0, 5)
		params := make([]interface{}, 0, 5)
		retCols := make([]string, 0, 5)
		retVars := make([]interface{}, 0, 5)

		if isDeletionFields(input.Deletions, "subject") {
			return nil, errors.New("couldn't set subject to null")
		}
		if input.Subject != nil {
			fields = append(fields, `"subject"`)
			params = append(params, *input.Subject)
			node.Subject = *input.Subject
		} else {
			retCols = append(retCols, `"subject"`)
			retVars = append(retVars, &node.Subject)
		}

		if isDeletionFields(input.Deletions, "name") {
			fields = append(fields, `"name"`)
			params = append(params, sql.NullString{})
			node.Name = sql.NullString{}
		} else if input.Name != nil {
			fields = append(fields, `"name"`)
			params = append(params, *input.Name)
			node.Name = sql.NullString{String: *input.Name, Valid: true}
		} else {
			retCols = append(retCols, `"name"`)
			retVars = append(retVars, &node.Name)
		}

		if isDeletionFields(input.Deletions, "createdDate") {
			fields = append(fields, `"created_date"`)
			params = append(params, NullTime{})
			node.CreatedDate = NullTime{}
		} else if input.CreatedDate != nil {
			fields = append(fields, `"created_date"`)
			params = append(params, input.CreatedDate.Time)
			node.CreatedDate = NullTime{Time: input.CreatedDate.Time, Valid: true}
		} else {
			retCols = append(retCols, `"created_date"`)
			retVars = append(retVars, &node.CreatedDate)
		}

		if isDeletionFields(input.Deletions, "changedDate") {
			fields = append(fields, `"changed_date"`)
			params = append(params, NullTime{})
			node.ChangedDate = NullTime{}
		} else if input.ChangedDate != nil {
			fields = append(fields, `"changed_date"`)
			params = append(params, input.ChangedDate.Time)
			node.ChangedDate = NullTime{Time: input.ChangedDate.Time, Valid: true}
		} else {
			retCols = append(retCols, `"changed_date"`)
			retVars = append(retVars, &node.ChangedDate)
		}

		if isDeletionFields(input.Deletions, "deletedDate") {
			fields = append(fields, `"deleted_date"`)
			params = append(params, NullTime{})
			node.DeletedDate = NullTime{}
		} else if input.DeletedDate != nil {
			fields = append(fields, `"deleted_date"`)
			params = append(params, input.DeletedDate.Time)
			node.DeletedDate = NullTime{Time: input.DeletedDate.Time, Valid: true}
		} else {
			retCols = append(retCols, `"deleted_date"`)
			retVars = append(retVars, &node.DeletedDate)
		}
		if len(params) == 0 {
			return nil, errors.New("all fields are empty, unable to update")
		}

		if err := r.ext.storage.UpdateUserByFields(r.ext.db, node, fields, retCols, params, retVars); err != nil {
			return nil, err
		}

		results[i] = UserResolver{ext: r.ext, node: node}
	}
	return results, nil
}

// DeleteUserGraphQL is the GraphQL end point for DeleteUser
func (r *RootResolver) DeleteUsers(ctx context.Context, args struct{ Input []DeleteUserInput }) ([]graphql.ID, error) {

	res, err := r.deleteUserGraphQL(ctx, args.Input)

	// event record
	if r.ext.recorder != nil {
		if err := r.ext.recorder.RecordEvent(ctx, "Users", "Delete", res); err != nil {
			r.ext.logger.Warnf("unable to record event, resource:Users, action:Delete, err:%v", err)
		}
	}
	return res, err
}

func (r *RootResolver) deleteUserGraphQL(ctx context.Context, items []DeleteUserInput) ([]graphql.ID, error) {
	results := make([]graphql.ID, len(items))
	inputs := make([]*User, len(items))

	for i := range items {
		input := items[i]

		id, err := strconv.Atoi(string(input.ID))
		if err != nil {
			return nil, errors.New("ID must be an integer")
		}

		results[i] = input.ID
		inputs[i] = &User{ID: id}
	}

	err := r.ext.storage.DeleteUsers(r.ext.db, inputs)
	if err != nil {
		return nil, err
	}

	return results, nil
}
