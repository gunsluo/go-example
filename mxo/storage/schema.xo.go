// Package storage contains the types for schema.
package storage

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"encoding/base64"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"time"

	"github.com/graph-gophers/graphql-go"
	"github.com/jmoiron/sqlx"
	"github.com/shopspring/decimal"
	"go.uber.org/zap"
)

// Storager is interface structure for database operation that can be called
type Storager interface {
	// InsertAccount inserts the Account to the database.
	InsertAccount(db XODB, a *Account) error
	// InsertAccountByFields inserts the Account to the database.
	InsertAccountByFields(db XODB, a *Account) error
	// DeleteAccount deletes the Account from the database.
	DeleteAccount(db XODB, a *Account) error
	// DeleteAccounts deletes the Account from the database.
	DeleteAccounts(db XODB, a []*Account) error
	// Update updates the Account in the database.
	UpdateAccount(db XODB, a *Account) error
	// UpdateAccountByFields updates the Account in the database.
	UpdateAccountByFields(db XODB, a *Account, fields, retCols []string, params, retVars []interface{}) error
	// Save saves the Account to the database.
	SaveAccount(db XODB, a *Account) error
	// Upsert performs an upsert for Account.
	UpsertAccount(db XODB, a *Account) error
	// GetMostRecentAccount returns n most recent rows from 'account',
	// ordered by "created_date" in descending order.
	GetMostRecentAccount(db XODB, n int) ([]*Account, error)
	// GetMostRecentChangedAccount returns n most recent rows from 'account',
	// ordered by "changed_date" in descending order.
	GetMostRecentChangedAccount(db XODB, n int) ([]*Account, error)
	// GetAllAccount returns all rows from 'account', based on the AccountQueryArguments.
	// If the AccountQueryArguments is nil, it will use the default AccountQueryArguments instead.
	GetAllAccount(db XODB, queryArgs *AccountQueryArguments) ([]*Account, error)
	// CountAllAccount returns a count of all rows from 'account'
	CountAllAccount(db XODB, queryArgs *AccountQueryArguments) (int, error)
	// InsertUser inserts the User to the database.
	InsertUser(db XODB, u *User) error
	// InsertUserByFields inserts the User to the database.
	InsertUserByFields(db XODB, u *User) error
	// DeleteUser deletes the User from the database.
	DeleteUser(db XODB, u *User) error
	// DeleteUsers deletes the User from the database.
	DeleteUsers(db XODB, u []*User) error
	// Update updates the User in the database.
	UpdateUser(db XODB, u *User) error
	// UpdateUserByFields updates the User in the database.
	UpdateUserByFields(db XODB, u *User, fields, retCols []string, params, retVars []interface{}) error
	// Save saves the User to the database.
	SaveUser(db XODB, u *User) error
	// Upsert performs an upsert for User.
	UpsertUser(db XODB, u *User) error
	// GetMostRecentUser returns n most recent rows from 'user',
	// ordered by "created_date" in descending order.
	GetMostRecentUser(db XODB, n int) ([]*User, error)
	// GetMostRecentChangedUser returns n most recent rows from 'user',
	// ordered by "changed_date" in descending order.
	GetMostRecentChangedUser(db XODB, n int) ([]*User, error)
	// GetAllUser returns all rows from 'user', based on the UserQueryArguments.
	// If the UserQueryArguments is nil, it will use the default UserQueryArguments instead.
	GetAllUser(db XODB, queryArgs *UserQueryArguments) ([]*User, error)
	// CountAllUser returns a count of all rows from 'user'
	CountAllUser(db XODB, queryArgs *UserQueryArguments) (int, error)
	// UsersBySubjectFK retrieves rows from user by foreign key Subject.
	// Generated from foreign key Account.
	UsersBySubjectFK(db XODB, subject string, queryArgs *UserQueryArguments) ([]*User, error)
	// CountUsersBySubjectFK count rows from user by foreign key Subject.
	// Generated from foreign key Account.
	CountUsersBySubjectFK(db XODB, subject string, queryArgs *UserQueryArguments) (int, error)
	// AccountInUser returns the Account associated with the User's Subject (subject).
	// Generated from foreign key 'user_account_subject_fk'.
	AccountInUser(db XODB, u *User) (*Account, error)
	// AccountByID retrieves a row from '"public"."account"' as a Account.
	// Generated from index 'account_pk'.
	AccountByID(db XODB, id int) (*Account, error)
	// AccountBySubject retrieves a row from '"public"."account"' as a Account.
	// Generated from index 'account_subject_unique_index'.
	AccountBySubject(db XODB, subject string) (*Account, error)
	// UserByID retrieves a row from '"public"."user"' as a User.
	// Generated from index 'user_pk'.
	UserByID(db XODB, id int) (*User, error)
}

// PostgresStorage is Postgres for the database.
type PostgresStorage struct {
	Logger Logger
}

// MssqlStorage is Mssql for the database.
type MssqlStorage struct {
	Logger Logger
}

// GodrorStorage is Godror for the database.
type GodrorStorage struct {
	Logger Logger
}

// New is a construction method that return a new Storage
func New(driver string, opts ...Option) (Storager, error) {
	o := applyOptions(opts...)

	var s Storager
	switch driver {
	case "postgres":
		s = &PostgresStorage{Logger: o.logger}
	case "mssql":
		s = &MssqlStorage{Logger: o.logger}
	case "godror":
		s = &GodrorStorage{Logger: o.logger}
	default:
		return nil, errors.New("driver " + driver + " not support")
	}

	return s, nil
}

// Account represents a row from '"public"."account"'.
type Account struct {
	ID          int            `db:"id" json:"id"`                     // id
	Subject     string         `db:"subject" json:"subject"`           // subject
	Email       string         `db:"email" json:"email"`               // email
	Name        string         `db:"name" json:"name"`                 // name
	Label       sql.NullString `db:"label" json:"label"`               // label
	CreatedDate sql.NullTime   `db:"created_date" json:"created_date"` // created_date
	ChangedDate sql.NullTime   `db:"changed_date" json:"changed_date"` // changed_date
	DeletedDate sql.NullTime   `db:"deleted_date" json:"deleted_date"` // deleted_date
}

// User represents a row from '"public"."user"'.
type User struct {
	ID          int            `db:"id" json:"id"`                     // id
	Subject     string         `db:"subject" json:"subject"`           // subject
	Name        sql.NullString `db:"name" json:"name"`                 // name
	CreatedDate sql.NullTime   `db:"created_date" json:"created_date"` // created_date
	ChangedDate sql.NullTime   `db:"changed_date" json:"changed_date"` // changed_date
	DeletedDate sql.NullTime   `db:"deleted_date" json:"deleted_date"` // deleted_date
}

// extension block
// GraphQL extension

// GraphQL related types
const GraphQLCommonTypes = `
        type PageInfo {
            hasNextPage: Boolean!
            hasPreviousPage: Boolean!
            startCursor: ID
            endCursor: ID
        }
        scalar Time
        enum FilterConjunction{
            AND
            OR
        }
    `

// PageInfoResolver defines the GraphQL PageInfo type
type PageInfoResolver struct {
	startCursor     graphql.ID
	endCursor       graphql.ID
	hasNextPage     bool
	hasPreviousPage bool
}

// StartCursor returns the start cursor (global id)
func (r *PageInfoResolver) StartCursor() *graphql.ID {
	return &r.startCursor
}

// EndCursor returns the end cursor (global id)
func (r *PageInfoResolver) EndCursor() *graphql.ID {
	return &r.endCursor
}

// HasNextPage returns if next page is available
func (r *PageInfoResolver) HasNextPage() bool {
	return r.hasNextPage
}

// HasPreviousPage returns if previous page is available
func (r *PageInfoResolver) HasPreviousPage() bool {
	return r.hasNextPage
}

// ResolverConfig is a config for Resolver
type ResolverConfig struct {
	Logger   Logger
	DB       *sqlx.DB
	S        Storager
	Recorder EventRecorder
	Verifier Verifier
}

// ResolverExtensions it's passing between root resolver and  children resolver
type ResolverExtensions struct {
	Logger   Logger
	DB       *sqlx.DB
	Storage  Storager
	Recorder EventRecorder
	Values   *sync.Map
	Mutex    *sync.Mutex
	Verifier Verifier
}

func (re *ResolverExtensions) WithValue(key string, value interface{}) {
	re.Values.Store(key, value)
}

func (re *ResolverExtensions) Value(key string) interface{} {
	value, _ := re.Values.Load(key)
	return value
}

// RootResolver is a graphql root resolver
type RootResolver struct {
	Ext ResolverExtensions
}

// NewRootResolver return a root resolver for ggraphql
func NewRootResolver(c *ResolverConfig) *RootResolver {
	return &RootResolver{
		Ext: NewResolverExtensions(c),
	}
}

// NewResolverExtensions create a resolver extension by config
func NewResolverExtensions(c *ResolverConfig) ResolverExtensions {
	var logger Logger
	if c.Logger == nil {
		logger = NewZapLogger(zap.NewNop())
	} else {
		logger = c.Logger
	}

	return ResolverExtensions{
		Logger:   logger,
		DB:       c.DB,
		Storage:  c.S,
		Recorder: c.Recorder,
		Values:   &sync.Map{},
		Mutex:    &sync.Mutex{},
		Verifier: c.Verifier,
	}
}

// BuildSchemaString build root schema string
func (r *RootResolver) BuildSchemaString(extraQueries, extraMutations, extraTypes string) string {
	return `
        schema {
            query: Query
            mutation: Mutation
        }

        type Query {
    ` +
		r.GetAccountQueries() +
		r.GetUserQueries() + extraQueries +
		`}

    type Mutation {
    ` +
		r.GetAccountMutations() +
		r.GetUserMutations() + extraMutations +
		`}

    ` +
		r.GetAccountTypes() +
		r.GetUserTypes() +
		GraphQLCommonTypes +
		extraTypes
}

func encodeCursor(typeName string, id int) graphql.ID {
	return graphql.ID(base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%s:%d", typeName, id))))
}

// EventRecorder is event recorder
type EventRecorder interface {
	RecordEvent(ctx context.Context, resource, action string, args interface{}) error
}

// Bool returns a nullable bool.
func Bool(b bool) sql.NullBool {
	return sql.NullBool{Bool: b, Valid: true}
}

// BoolPointer converts bool pointer to sql.NullBool
func BoolPointer(b *bool) sql.NullBool {
	if b == nil {
		return sql.NullBool{}
	}
	return sql.NullBool{Bool: *b, Valid: true}
}

// PointerBool converts bool to pointer to bool
func PointerBool(b sql.NullBool) *bool {
	if !b.Valid {
		return nil
	}
	return &b.Bool
}

// NullDecimalString converts decimal.NullDecimal to *string
func NullDecimalString(b decimal.NullDecimal) *string {
	if !b.Valid {
		return nil
	}
	x := b.Decimal.String()
	return &x
}

// Int64 returns a nullable int64
func Int64(i int64) sql.NullInt64 {
	return sql.NullInt64{Int64: i, Valid: true}
}

// Int64Pointer converts a int64 pointer to sql.NullInt64
func Int64Pointer(i *int64) sql.NullInt64 {
	if i == nil {
		return sql.NullInt64{}
	}
	return sql.NullInt64{Int64: *i, Valid: true}
}

// PointerInt64 converts sql.NullInt64 to pointer to int64
func PointerInt64(i sql.NullInt64) *int64 {
	if !i.Valid {
		return nil
	}
	return &i.Int64
}

// Float64 returns a nullable float64
func Float64(i float64) sql.NullFloat64 {
	return sql.NullFloat64{Float64: i, Valid: true}
}

// Float64Pointer converts a float64 pointer to sql.NullFloat64
func Float64Pointer(i *float64) sql.NullFloat64 {
	if i == nil {
		return sql.NullFloat64{}
	}
	return sql.NullFloat64{Float64: *i, Valid: true}
}

// PointerFloat64 converts sql.NullFloat64 to pointer to float64
func PointerFloat64(i sql.NullFloat64) *float64 {
	if !i.Valid {
		return nil
	}
	return &i.Float64
}

// String returns a nullable string
func String(s string) sql.NullString {
	return sql.NullString{String: s, Valid: true}
}

// StringPointer converts string pointer to sql.NullString
func StringPointer(s *string) sql.NullString {
	if s == nil {
		return sql.NullString{}
	}
	return sql.NullString{String: *s, Valid: true}
}

// PointerString converts sql.NullString to pointer to string
func PointerString(s sql.NullString) *string {
	if !s.Valid {
		return nil
	}
	return &s.String
}

// Time returns a nullable Time
func Time(t time.Time) sql.NullTime {
	return sql.NullTime{Time: t, Valid: true}
}

// TimePointer converts time.Time pointer to sql.NullTime
func TimePointer(t *time.Time) sql.NullTime {
	if t == nil {
		return sql.NullTime{}
	}
	return sql.NullTime{Time: *t, Valid: true}
}

// TimeGqlPointer converts graphql.Time pointer to sql.NullTime
func TimeGqlPointer(t *graphql.Time) sql.NullTime {
	if t == nil {
		return sql.NullTime{}
	}
	return sql.NullTime{Time: t.Time, Valid: true}
}

// PointerTime converts NullTIme to pointer to time.Time
func PointerTime(t sql.NullTime) *time.Time {
	if !t.Valid {
		return nil
	}
	return &t.Time
}

// PointerGqlTime converts NullType to pointer to graphql.Time
func PointerGqlTime(t sql.NullTime) *graphql.Time {
	if !t.Valid {
		return nil
	}
	return &graphql.Time{Time: t.Time}
}

// PointerStringInt64 converts Int64 pointer to string pointer
func PointerStringInt64(i *int64) *string {
	if i == nil {
		return nil
	}
	s := strconv.Itoa(int(*i))
	return &s
}

// PointerStringSqlInt64 converts sql.NullInt64 pointer to graphql.ID pointer
func PointerStringSqlInt64(i sql.NullInt64) *string {
	if !i.Valid {
		return nil
	}
	s := strconv.Itoa(int(i.Int64))
	return &s
}

// PointerStringFloat64 converts Float64 pointer to string pointer
func PointerStringFloat64(i *float64) *string {
	if i == nil {
		return nil
	}
	s := fmt.Sprintf("%.6f", *i)
	return &s
}

// PointerFloat64SqlFloat64 converts sql.NullFloat64 pointer to graphql.ID pointer
func PointerFloat64SqlFloat64(i sql.NullFloat64) *float64 {
	if !i.Valid {
		return nil
	}
	s := i.Float64
	return &s
}

// access control
// Verifier is access control verifier
type Verifier interface {
	VerifyAC(ctx context.Context, resource, action string, args interface{}) error
	VerifyRefAC(ctx context.Context, resource, action string, args interface{}) error
}

// GraphQLResource is a resource of graphql API
type GraphQLResource struct {
	Name     string
	Describe string
}

// GetResolverResources get all resource
func (r *RootResolver) GetResolverResources(includes []GraphQLResource, excludes []string) ([]GraphQLResource, error) {
	uniqueResources := make(map[string]GraphQLResource)
	for _, r := range r.getAccountGraphQLResources() {
		if v, ok := uniqueResources[r.Name]; ok {
			return nil, fmt.Errorf("duplicate resource %s", v.Name)
		} else {
			uniqueResources[v.Name] = v
		}
	}
	for _, r := range r.getUserGraphQLResources() {
		if v, ok := uniqueResources[r.Name]; ok {
			return nil, fmt.Errorf("duplicate resource %s", v.Name)
		} else {
			uniqueResources[v.Name] = v
		}
	}

	for _, r := range includes {
		if v, ok := uniqueResources[r.Name]; ok {
			return nil, fmt.Errorf("duplicate resource %s", v.Name)
		} else {
			uniqueResources[v.Name] = v
		}
	}

	for _, k := range excludes {
		delete(uniqueResources, k)
	}

	var resources []GraphQLResource
	for _, v := range uniqueResources {
		resources = append(resources, v)
	}

	return resources, nil
}

// specific for oracle
var (
	ORALCE_EMPTY_STRING = "__EMPTY__"
)

// RealOracleEmptyString is real value of empty string in oracle
func RealOracleEmptyString(s string) string {
	if s == "" {
		return ORALCE_EMPTY_STRING
	}
	return s
}

// RealOracleNullString is real value of null string in oracle
func RealOracleNullString(ns sql.NullString) sql.NullString {
	if !ns.Valid {
		return sql.NullString{}
	}

	if ns.String == "" {
		return sql.NullString{String: ORALCE_EMPTY_STRING, Valid: true}
	}

	return sql.NullString{String: ns.String, Valid: true}
}

// FixRealOracleEmptyString fix the value from real value of empty string in oracle
func FixRealOracleEmptyString(s *string) {
	if *s == ORALCE_EMPTY_STRING {
		*s = ""
	}
}

// FixRealOracleNullString fix the value from real value of null string in oracle
func FixRealOracleNullString(ns *sql.NullString) {
	if ns == nil || !ns.Valid {
		return
	}

	if ns.String == "" {
		ns.Valid = false
		return
	}

	if ns.String == ORALCE_EMPTY_STRING {
		ns.String = ""
	}
}
