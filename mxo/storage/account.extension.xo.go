// Package storage contains the types for schema.
package storage

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"strconv"

	"github.com/graph-gophers/graphql-go"
	"github.com/pkg/errors"
)

// AccountFilter related to AccountQueryArguments
// struct field name contain table column name in Camel style and logic operator(lt, gt etc)
// only indexed column and special column defined in ExtraFilters declared in file extra_rules.yaml
type AccountFilter struct {
	Conjunction   *string // enum in "AND", "OR", nil(consider as single condition)
	Subject       *string `json:"subject"`        // equal to Subject
	SubjectLike   *string `json:"subject_like"`   // LIKE
	SubjectILike  *string `json:"subject_ilike"`  // ILIKE case-insensitive
	SubjectNLike  *string `json:"subject_nlike"`  // NOT LIKE
	SubjectNILike *string `json:"subject_nilike"` // NOT ILIKE case-insensitive
}

// AccountQueryArguments composed by Cursor, AccountFilter and sql filter string
type AccountQueryArguments struct {
	Cursor
	Where *AccountFilter

	// non-export field
	filterArgs *filterArguments
}

// getAccountFilter return the sql filter
func getAccountFilter(filter *AccountFilter) (*filterArguments, error) {
	if filter == nil {
		return nil, nil
	}
	conjunction := ""
	conjCnt := 0
	var filterPairs []*filterPair
	if filter.Conjunction != nil {
		conjunction = *filter.Conjunction
		if _, ok := sqlConjunctionMap[conjunction]; !ok {
			return nil, fmt.Errorf("unsupported conjunction:%v", filter.Conjunction)
		}
	}
	if filter.Subject != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "=", value: *filter.Subject})
	}
	if filter.SubjectLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "LIKE", value: *filter.SubjectLike})
	}
	if filter.SubjectILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "ILIKE", value: *filter.SubjectILike})
	}
	if filter.SubjectNLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "NOT LIKE", value: *filter.SubjectNLike})
	}
	if filter.SubjectNILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "NOT ILIKE", value: *filter.SubjectNILike})
	}
	if conjCnt == 0 {
		return nil, nil
	}
	if len(conjunction) > 0 && conjCnt < 2 {
		return nil, fmt.Errorf("invalid filter conjunction: %v need more than 2 parameter but have: %v", *filter.Conjunction, conjCnt)
	}
	if len(conjunction) == 0 && conjCnt != 1 {
		return nil, fmt.Errorf("multi field:%v should be connected by conjunction AND or OR", conjCnt)
	}
	filterArgs := &filterArguments{filterPairs: filterPairs, conjunction: conjunction, conjCnt: conjCnt}
	return filterArgs, nil
}

// ApplyAccountQueryArgsDefaults assigns default cursor values to non-nil fields.
func ApplyAccountQueryArgsDefaults(queryArgs *AccountQueryArguments) *AccountQueryArguments {
	if queryArgs == nil {
		queryArgs = &AccountQueryArguments{
			Cursor: DefaultCursor,
		}
		return queryArgs
	}
	if queryArgs.Offset == nil {
		queryArgs.Offset = DefaultCursor.Offset
	}
	if queryArgs.Limit == nil {
		queryArgs.Limit = DefaultCursor.Limit
	}
	if queryArgs.OrderBy == nil {
		queryArgs.OrderBy = DefaultCursor.OrderBy
	}
	if queryArgs.Desc == nil {
		queryArgs.Desc = DefaultCursor.Desc
	}
	if queryArgs.Dead == nil {
		queryArgs.Dead = DefaultCursor.Dead
	}
	if queryArgs.After == nil {
		queryArgs.After = DefaultCursor.After
	}
	if queryArgs.First == nil {
		queryArgs.First = DefaultCursor.First
	}
	if queryArgs.Before == nil {
		queryArgs.Before = DefaultCursor.Before
	}
	if queryArgs.Last == nil {
		queryArgs.Last = DefaultCursor.Last
	}
	return queryArgs
}

// extension block
const graphQLAccountQueries = `
        allAccounts(where: AccountFilter, offset: Int, limit: Int, orderBy: String, desc: Boolean): AccountConnection!
        accountByID(id:ID!):Account
        accountBySubject(subject:String!):Account
    `

const graphQLAccountMutations = `
        insertAccounts(input: [InsertAccountInput!]!): [Account!]!
        updateAccounts(input: [UpdateAccountInput!]!): [Account!]!
        deleteAccounts(input: [DeleteAccountInput!]!): [ID!]!
    `

var graphQLAccountTypes = `
        type Account {
            id: ID!
            subject: String!
            email: String!
            name: String!
            label: String
            createdDate: Time
            changedDate: Time
            deletedDate: Time
            usersSubject(offset: Int, limit: Int, orderBy: String, desc: Boolean): UserConnection!
        }

        type AccountConnection {
            pageInfo: PageInfo!
            edges: [AccountEdge]
            totalCount: Int
            accounts: [Account]
        }

        type AccountEdge {
            node: Account
            cursor: ID!
        }
    
        input AccountFilter {
            conjunction: FilterConjunction
            subject: String
            subject_like: String // LIKE
            subject_ilike: String // LIKE case insensitive
            subject_nlike: String	// NOT LIKE
            subject_nilike: String // NOT LIKE case insensitive
        }

        input InsertAccountInput {
            subject: String!
            email: String!
            name: String!
            label: String
            createdDate: Time
            changedDate: Time
            deletedDate: Time
        }

        input UpdateAccountInput {
            id: ID!
            subject: String
            email: String
            name: String
            label: String
            createdDate: Time
            changedDate: Time
            deletedDate: Time
            _deletions: [String!]
        }

        input DeleteAccountInput {
            id: ID!
        }
    `

// GetAccountQueries specifies the GraphQL queries for Account
func (r *RootResolver) GetAccountQueries() string {
	return graphQLAccountQueries
}

// GetAccountMutations specifies the GraphQL mutations for Account
func (r *RootResolver) GetAccountMutations() string {
	return graphQLAccountMutations
}

// GetAccountTypes specifies the GraphQL types for Account
func (r *RootResolver) GetAccountTypes() string {
	return graphQLAccountTypes
}

// AccountResolver defines the GraphQL resolver for 'Account'.
type AccountResolver struct {
	Ext  ResolverExtensions
	node *Account
}

// AccountResolver defines a GraphQL resolver for Account
func NewAccountResolver(node *Account, ext ResolverExtensions) *AccountResolver {
	return &AccountResolver{Ext: ext, node: node}
}

// Node get node for AccountResolver
func (r AccountResolver) Node() *Account {
	return r.node
}
func (r AccountResolver) ID() graphql.ID             { return graphql.ID(strconv.Itoa(r.node.ID)) }
func (r AccountResolver) Subject() string            { return r.node.Subject }
func (r AccountResolver) Email() string              { return r.node.Email }
func (r AccountResolver) Name() string               { return r.node.Name }
func (r AccountResolver) Label() *string             { return PointerString(r.node.Label) }
func (r AccountResolver) CreatedDate() *graphql.Time { return PointerGqlTime(r.node.CreatedDate) }
func (r AccountResolver) ChangedDate() *graphql.Time { return PointerGqlTime(r.node.ChangedDate) }
func (r AccountResolver) DeletedDate() *graphql.Time { return PointerGqlTime(r.node.DeletedDate) }
func (r AccountResolver) UsersSubject(ctx context.Context, queryArgs *UserQueryArguments) (*UserConnectionResolver, error) {
	if r.Ext.Verifier == nil {
		return nil, errors.New("enable ac, please set verifier")
	}
	if err := r.Ext.Verifier.VerifyRefAC(ctx, "Accounts", "RefGet", r); err != nil {
		return nil, errors.Wrap(err, "Accounts:RefGet")
	}

	if queryArgs != nil && (queryArgs.After != nil || queryArgs.First != nil || queryArgs.Before != nil || queryArgs.Last != nil) {
		return nil, errors.New("not implemented yet, use offset + limit for pagination")
	}

	queryArgs = ApplyUserQueryArgsDefaults(queryArgs)

	subject := r.node.Subject

	data, err := r.Ext.Storage.UsersBySubjectFK(r.Ext.DB, subject, queryArgs)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get Users")
	}

	count, err := r.Ext.Storage.CountUsersBySubjectFK(r.Ext.DB, subject, queryArgs)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get Users count")
	}

	return &UserConnectionResolver{
		Ext:   r.Ext,
		data:  data,
		count: int32(count),
	}, nil
}

// AccountByID generated by account_pk
func (r *RootResolver) AccountByID(ctx context.Context, args struct {
	ID graphql.ID
}) (*AccountResolver, error) {
	if r.Ext.Verifier == nil {
		return nil, errors.New("enable ac, please set verifier")
	}
	if err := r.Ext.Verifier.VerifyAC(ctx, "Accounts", "Get", args); err != nil {
		return nil, errors.Wrap(err, "Accounts:Get")
	}

	res, err := r.innerAccountByIDGraphQL(ctx, args)

	// event record
	if r.Ext.Recorder != nil {
		if err := r.Ext.Recorder.RecordEvent(ctx, "Accounts", "Get", res); err != nil {
			r.Ext.Logger.Warnf("unable to record event, resource:Accounts, action:Get, err:%v", err)
		}
	}
	return res, err
}

// innerAccountByIDGraphQL retrieves a row from '"public"."account"' as a Account.
// Generated from index 'account_pk'.
func (r *RootResolver) innerAccountByIDGraphQL(ctx context.Context, args struct {
	ID graphql.ID
}) (*AccountResolver, error) {

	arg0, err := strconv.Atoi(string(args.ID))
	if err != nil {
		return nil, errors.Wrap(err, `ID should be integer`)
	}

	data, err := r.Ext.Storage.AccountByID(r.Ext.DB, arg0)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, errors.Errorf(`account [`+"%v"+`] not found`, arg0)
		}
		return nil, errors.Wrap(err, `unable to get "public"."account"`)
	}

	return NewAccountResolver(data, r.Ext), nil

}

// AccountBySubject generated by account_subject_unique_index
func (r *RootResolver) AccountBySubject(ctx context.Context, args struct {
	Subject string
}) (*AccountResolver, error) {
	if r.Ext.Verifier == nil {
		return nil, errors.New("enable ac, please set verifier")
	}
	if err := r.Ext.Verifier.VerifyAC(ctx, "Accounts.AccountBySubject", "NonPrimaryKeyGet", args); err != nil {
		return nil, errors.Wrap(err, "Accounts.AccountBySubject:NonPrimaryKeyGet")
	}

	res, err := r.innerAccountBySubjectGraphQL(ctx, args)

	// event record
	if r.Ext.Recorder != nil {
		if err := r.Ext.Recorder.RecordEvent(ctx, "Accounts.AccountBySubject", "NonPrimaryKeyGet", res); err != nil {
			r.Ext.Logger.Warnf("unable to record event, resource:Accounts.AccountBySubject, action:NonPrimaryKeyGet, err:%v", err)
		}
	}
	return res, err
}

// innerAccountBySubjectGraphQL retrieves a row from '"public"."account"' as a Account.
// Generated from index 'account_subject_unique_index'.
func (r *RootResolver) innerAccountBySubjectGraphQL(ctx context.Context, args struct {
	Subject string
}) (*AccountResolver, error) {

	arg0 := args.Subject

	data, err := r.Ext.Storage.AccountBySubject(r.Ext.DB, arg0)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, errors.Errorf(`account [`+"%v"+`] not found`, arg0)
		}
		return nil, errors.Wrap(err, `unable to get "public"."account"`)
	}

	return NewAccountResolver(data, r.Ext), nil

}

// AccountConnectionResolver defines a GraphQL resolver for AccountConnection
type AccountConnectionResolver struct {
	Ext ResolverExtensions

	data  []*Account
	count int32
}

// NewAccountConnectionResolver return a GraphQL resolver for AccountConnection
func NewAccountConnectionResolver(data []*Account, count int, ext ResolverExtensions) *AccountConnectionResolver {
	return &AccountConnectionResolver{
		Ext:   ext,
		data:  data,
		count: int32(count),
	}
}

// PageInfo returns PageInfo
func (r AccountConnectionResolver) PageInfo() *PageInfoResolver {
	if len(r.data) == 0 {
		return &PageInfoResolver{}
	}

	return &PageInfoResolver{
		startCursor:     encodeCursor("Account", int(r.data[0].ID)),
		endCursor:       encodeCursor("Account", int(r.data[len(r.data)-1].ID)),
		hasNextPage:     false, // TODO
		hasPreviousPage: false, // TODO
	}
}

// Edges returns standard GraphQL edges
func (r AccountConnectionResolver) Edges() *[]*AccountEdgeResolver {
	edges := make([]*AccountEdgeResolver, len(r.data))

	for i := range r.data {
		edges[i] = NewAccountEdgeResolver(r.data[i], r.Ext)
	}
	return &edges
}

// TotalCount returns total count
func (r AccountConnectionResolver) TotalCount() *int32 {
	return &r.count
}

// Accounts returns the list of Account
func (r AccountConnectionResolver) Accounts() *[]*AccountResolver {
	data := make([]*AccountResolver, len(r.data))
	for i := range r.data {
		data[i] = NewAccountResolver(r.data[i], r.Ext)
	}
	return &data
}

// AccountEdgeResolver defines the Account edge
type AccountEdgeResolver struct {
	Ext  ResolverExtensions
	node *Account
}

// NewAccountEdgeResolver return a GraphQL resolver for AccountEdgeResolver
func NewAccountEdgeResolver(node *Account, ext ResolverExtensions) *AccountEdgeResolver {
	return &AccountEdgeResolver{
		Ext:  ext,
		node: node,
	}
}

// Node returns the Account node
func (r AccountEdgeResolver) Node() *AccountResolver {
	return NewAccountResolver(r.node, r.Ext)
}

// Cursor returns the cursor
func (r AccountEdgeResolver) Cursor() graphql.ID {
	return encodeCursor("Account", int(r.node.ID))
}

// InsertAccountInput defines the insert Account mutation input
type InsertAccountInput struct {
	Subject     string
	Email       string
	Name        string
	Label       *string
	CreatedDate *graphql.Time
	ChangedDate *graphql.Time
	DeletedDate *graphql.Time
}

// UpdateAccountInput defines the update Account mutation input
type UpdateAccountInput struct {
	ID          graphql.ID
	Subject     *string
	Email       *string
	Name        *string
	Label       *string
	CreatedDate *graphql.Time
	ChangedDate *graphql.Time
	DeletedDate *graphql.Time
	updateArguments
}

// DeleteAccountInput defines the delete Account mutation input
type DeleteAccountInput struct {
	ID graphql.ID
}

// ConvertInsertAccountInput convert InsertAccountInput to Account
func ConvertInsertAccountInput(input InsertAccountInput) (*Account, error) {

	f1 := input.Subject
	f2 := input.Email
	f3 := input.Name
	f4 := StringPointer(input.Label)
	f5 := TimeGqlPointer(input.CreatedDate)
	f6 := TimeGqlPointer(input.ChangedDate)
	f7 := TimeGqlPointer(input.DeletedDate)
	node := &Account{
		Subject:     f1,
		Email:       f2,
		Name:        f3,
		Label:       f4,
		CreatedDate: f5,
		ChangedDate: f6,
		DeletedDate: f7,
	}

	return node, nil
}

// ConvertUpdateAccountInput convert UpdateAccountInput to Account
func ConvertUpdateAccountInput(input UpdateAccountInput) (*Account, []string, []string, []interface{}, []interface{}, error) {
	id, err := strconv.Atoi(string(input.ID))
	if err != nil {
		return nil, nil, nil, nil, nil, errors.New("ID must be an integer")
	}

	node := &Account{ID: id}
	fields := make([]string, 0, 7)
	params := make([]interface{}, 0, 7)
	retCols := make([]string, 0, 7)
	retVars := make([]interface{}, 0, 7)

	if isDeletionFields(input.Deletions, "subject") {
		return nil, nil, nil, nil, nil, errors.New("couldn't set subject to null")
	}
	if input.Subject != nil {
		fields = append(fields, `"subject"`)
		params = append(params, *input.Subject)
		node.Subject = *input.Subject
	} else {
		retCols = append(retCols, `"subject"`)
		retVars = append(retVars, &node.Subject)
	}

	if isDeletionFields(input.Deletions, "email") {
		return nil, nil, nil, nil, nil, errors.New("couldn't set email to null")
	}
	if input.Email != nil {
		fields = append(fields, `"email"`)
		params = append(params, *input.Email)
		node.Email = *input.Email
	} else {
		retCols = append(retCols, `"email"`)
		retVars = append(retVars, &node.Email)
	}

	if isDeletionFields(input.Deletions, "name") {
		return nil, nil, nil, nil, nil, errors.New("couldn't set name to null")
	}
	if input.Name != nil {
		fields = append(fields, `"name"`)
		params = append(params, *input.Name)
		node.Name = *input.Name
	} else {
		retCols = append(retCols, `"name"`)
		retVars = append(retVars, &node.Name)
	}

	if isDeletionFields(input.Deletions, "label") {
		fields = append(fields, `"label"`)
		params = append(params, sql.NullString{})
		node.Label = sql.NullString{}
	} else if input.Label != nil {
		fields = append(fields, `"label"`)
		params = append(params, *input.Label)
		node.Label = sql.NullString{String: *input.Label, Valid: true}
	} else {
		retCols = append(retCols, `"label"`)
		retVars = append(retVars, &node.Label)
	}

	if isDeletionFields(input.Deletions, "createdDate") {
		fields = append(fields, `"created_date"`)
		params = append(params, sql.NullTime{})
		node.CreatedDate = sql.NullTime{}
	} else if input.CreatedDate != nil {
		fields = append(fields, `"created_date"`)
		params = append(params, input.CreatedDate.Time)
		node.CreatedDate = sql.NullTime{Time: input.CreatedDate.Time, Valid: true}
	} else {
		retCols = append(retCols, `"created_date"`)
		retVars = append(retVars, &node.CreatedDate)
	}

	if isDeletionFields(input.Deletions, "changedDate") {
		fields = append(fields, `"changed_date"`)
		params = append(params, sql.NullTime{})
		node.ChangedDate = sql.NullTime{}
	} else if input.ChangedDate != nil {
		fields = append(fields, `"changed_date"`)
		params = append(params, input.ChangedDate.Time)
		node.ChangedDate = sql.NullTime{Time: input.ChangedDate.Time, Valid: true}
	} else {
		retCols = append(retCols, `"changed_date"`)
		retVars = append(retVars, &node.ChangedDate)
	}

	if isDeletionFields(input.Deletions, "deletedDate") {
		fields = append(fields, `"deleted_date"`)
		params = append(params, sql.NullTime{})
		node.DeletedDate = sql.NullTime{}
	} else if input.DeletedDate != nil {
		fields = append(fields, `"deleted_date"`)
		params = append(params, input.DeletedDate.Time)
		node.DeletedDate = sql.NullTime{Time: input.DeletedDate.Time, Valid: true}
	} else {
		retCols = append(retCols, `"deleted_date"`)
		retVars = append(retVars, &node.DeletedDate)
	}
	if len(params) == 0 {
		return nil, nil, nil, nil, nil, errors.New("all fields are empty, unable to update")
	}

	return node, fields, retCols, params, retVars, nil
}

// ConvertDeleteAccountInput convert DeleteAccountInput to Account
func ConvertDeleteAccountInput(input DeleteAccountInput) (*Account, error) {

	id, err := strconv.Atoi(string(input.ID))
	if err != nil {
		return nil, errors.New("ID must be an integer")
	}

	return &Account{ID: id}, nil
}

// ConvertDeleteAccountInputs convert DeleteAccountInput to Account
func ConvertDeleteAccountInputs(inputs []DeleteAccountInput) ([]*Account, []graphql.ID, error) {
	ids := make([]graphql.ID, len(inputs))
	nodes := make([]*Account, len(inputs))

	for i := range inputs {
		node, err := ConvertDeleteAccountInput(inputs[i])
		if err != nil {
			return nil, nil, err
		}

		nodes[i] = node
		ids[i] = inputs[i].ID
	}

	return nodes, ids, nil
}

// AllAccounts is a graphQL endpoint of AllAccounts
func (r *RootResolver) AllAccounts(ctx context.Context, args *AccountQueryArguments) (*AccountConnectionResolver, error) {
	if r.Ext.Verifier == nil {
		return nil, errors.New("enable ac, please set verifier")
	}
	if err := r.Ext.Verifier.VerifyAC(ctx, "Accounts", "GetAll", args); err != nil {
		return nil, errors.Wrap(err, "Accounts:GetAll")
	}

	res, err := r.allAccounts(ctx, args)

	// event record
	if r.Ext.Recorder != nil {
		if err := r.Ext.Recorder.RecordEvent(ctx, "Accounts", "GetAll", res); err != nil {
			r.Ext.Logger.Warnf("unable to record event, resource:Accounts, action:GetAll, err:%v", err)
		}
	}
	return res, err
}

func (r *RootResolver) allAccounts(ctx context.Context, queryArgs *AccountQueryArguments) (*AccountConnectionResolver, error) {
	if queryArgs != nil && (queryArgs.After != nil || queryArgs.First != nil || queryArgs.Before != nil || queryArgs.Last != nil) {
		return nil, errors.New("not implemented yet, use offset + limit for pagination")
	}

	queryArgs = ApplyAccountQueryArgsDefaults(queryArgs)

	filterArgs, err := getAccountFilter(queryArgs.Where)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get Account filter")
	}
	queryArgs.filterArgs = filterArgs

	allAccount, err := r.Ext.Storage.GetAllAccount(r.Ext.DB, queryArgs)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get Account")
	}

	count, err := r.Ext.Storage.CountAllAccount(r.Ext.DB, queryArgs)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get count")
	}

	return &AccountConnectionResolver{
		Ext:   r.Ext,
		data:  allAccount,
		count: int32(count),
	}, nil
}

// InsertAccounts is a graphQL endpoint of InsertAccounts
func (r *RootResolver) InsertAccounts(ctx context.Context, args struct{ Input []InsertAccountInput }) ([]AccountResolver, error) {
	if r.Ext.Verifier == nil {
		return nil, errors.New("enable ac, please set verifier")
	}
	if err := r.Ext.Verifier.VerifyAC(ctx, "Accounts", "Insert", args); err != nil {
		return nil, errors.Wrap(err, "Accounts:Insert")
	}

	tx, err := r.Ext.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, errors.Wrap(err, "unable to begin transcation")
	}

	results := make([]AccountResolver, len(args.Input))
	for i, input := range args.Input {
		node, err := ConvertInsertAccountInput(input)
		if err != nil {
			tx.Rollback()
			return nil, fmt.Errorf("invalid input in the request, %v %w", input, err)
		}

		if err := r.Ext.Storage.InsertAccountByFields(tx, node); err != nil {
			tx.Rollback()
			return nil, errors.Wrap(err, "unable to insert Account")
		}
		results[i] = AccountResolver{Ext: r.Ext, node: node}
	}

	if err := tx.Commit(); err != nil {
		return nil, errors.Wrap(err, "unable to commit")
	}

	// event record
	if r.Ext.Recorder != nil {
		if err := r.Ext.Recorder.RecordEvent(ctx, "Accounts", "Insert", results); err != nil {
			r.Ext.Logger.Warnf("unable to record event, resource:Accounts, action:Insert, err:%v", err)
		}
	}
	return results, err
}

// UpdateAccountGraphQL is the GraphQL end point for UpdateAccount
func (r *RootResolver) UpdateAccounts(ctx context.Context, args struct{ Input []UpdateAccountInput }) ([]AccountResolver, error) {
	if r.Ext.Verifier == nil {
		return nil, errors.New("enable ac, please set verifier")
	}
	if err := r.Ext.Verifier.VerifyAC(ctx, "Accounts", "Update", args); err != nil {
		return nil, errors.Wrap(err, "Accounts:Update")
	}

	tx, err := r.Ext.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, errors.Wrap(err, "unable to begin transcation")
	}

	results := make([]AccountResolver, len(args.Input))
	for i, input := range args.Input {
		node, fields, retCols, params, retVars, err := ConvertUpdateAccountInput(input)
		if err != nil {
			tx.Rollback()
			return nil, fmt.Errorf("invalid input in the request, %v %w", input, err)
		}

		if err := r.Ext.Storage.UpdateAccountByFields(tx, node, fields, retCols, params, retVars); err != nil {
			tx.Rollback()
			if err == sql.ErrNoRows {
				return nil, errors.Errorf(`Account [%d] not found`, node.ID)
			}
			return nil, err
		}

		results[i] = AccountResolver{Ext: r.Ext, node: node}
	}

	if err := tx.Commit(); err != nil {
		return nil, errors.Wrap(err, "unable to commit")
	}

	// event record
	if r.Ext.Recorder != nil {
		if err := r.Ext.Recorder.RecordEvent(ctx, "Accounts", "Update", results); err != nil {
			r.Ext.Logger.Warnf("unable to record event, resource:Accounts, action:Update, err: %v", err)
		}
	}

	return results, err
}

// DeleteAccountGraphQL is the GraphQL end point for DeleteAccount
func (r *RootResolver) DeleteAccounts(ctx context.Context, args struct{ Input []DeleteAccountInput }) ([]graphql.ID, error) {
	if r.Ext.Verifier == nil {
		return nil, errors.New("enable ac, please set verifier")
	}
	if err := r.Ext.Verifier.VerifyAC(ctx, "Accounts", "Delete", args); err != nil {
		return nil, errors.Wrap(err, "Accounts:Delete")
	}

	nodes, ids, err := ConvertDeleteAccountInputs(args.Input)
	if err != nil {
		return nil, errors.Wrap(err, "invalid input in the request")
	}

	err = r.Ext.Storage.DeleteAccounts(r.Ext.DB, nodes)
	if err != nil {
		return nil, err
	}

	// event record
	if r.Ext.Recorder != nil {
		if err := r.Ext.Recorder.RecordEvent(ctx, "Accounts", "Delete", ids); err != nil {
			r.Ext.Logger.Warnf("unable to record event, resource:Accounts, action:Delete, err:%v", err)
		}
	}
	return ids, err
}

func (r *RootResolver) getAccountGraphQLResources() []GraphQLResource {
	return []GraphQLResource{
		GraphQLResource{
			Name:     "Accounts",
			Describe: "This is a graphQL resource Accounts, have GetAll, Get, Insert, Update, Delete actions.",
		},
		GraphQLResource{
			Name:     "Accounts.AccountBySubject",
			Describe: "This is a graphQL resource Accounts.AccountBySubject, only have NonPrimaryKeyGet action.",
		},
	}
}
