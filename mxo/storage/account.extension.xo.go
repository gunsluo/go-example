// Package storage contains the types for schema.
package storage

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"strconv"

	"github.com/graph-gophers/graphql-go"
	"github.com/pkg/errors"
)

// AccountFilter related to AccountQueryArguments
// struct field name contain table column name in Camel style and logic operator(lt, gt etc)
// only indexed column and special column defined in ExtraFilters declared in file extra_rules.yaml
type AccountFilter struct {
	Conjunction   *string // enum in "AND", "OR", nil(consider as single condition)
	Subject       *string `json:"subject"`        // equal to Subject
	SubjectLike   *string `json:"subject_like"`   // LIKE
	SubjectILike  *string `json:"subject_ilike"`  // ILIKE case-insensitive
	SubjectNLike  *string `json:"subject_nlike"`  // NOT LIKE
	SubjectNILike *string `json:"subject_nilike"` // NOT ILIKE case-insensitive
}

// AccountQueryArguments composed by Cursor, AccountFilter and sql filter string
type AccountQueryArguments struct {
	Cursor
	Where *AccountFilter

	// non-export field
	filterArgs *filterArguments
}

// getAccountFilter return the sql filter
func getAccountFilter(filter *AccountFilter) (*filterArguments, error) {
	if filter == nil {
		return nil, nil
	}
	conjunction := ""
	conjCnt := 0
	var filterPairs []*filterPair
	if filter.Conjunction != nil {
		conjunction = *filter.Conjunction
		if _, ok := sqlConjunctionMap[conjunction]; !ok {
			return nil, fmt.Errorf("unsupported conjunction:%v", filter.Conjunction)
		}
	}
	if filter.Subject != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "=", value: *filter.Subject})
	}
	if filter.SubjectLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "LIKE", value: *filter.SubjectLike})
	}
	if filter.SubjectILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "ILIKE", value: *filter.SubjectILike})
	}
	if filter.SubjectNLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "NOT LIKE", value: *filter.SubjectNLike})
	}
	if filter.SubjectNILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "NOT ILIKE", value: *filter.SubjectNILike})
	}
	if conjCnt == 0 {
		return nil, nil
	}
	if len(conjunction) > 0 && conjCnt < 2 {
		return nil, fmt.Errorf("invalid filter conjunction: %v need more than 2 parameter but have: %v", *filter.Conjunction, conjCnt)
	}
	if len(conjunction) == 0 && conjCnt != 1 {
		return nil, fmt.Errorf("multi field:%v should be connected by conjunction AND or OR", conjCnt)
	}
	filterArgs := &filterArguments{filterPairs: filterPairs, conjunction: conjunction, conjCnt: conjCnt}
	return filterArgs, nil
}

// ApplyAccountQueryArgsDefaults assigns default cursor values to non-nil fields.
func ApplyAccountQueryArgsDefaults(queryArgs *AccountQueryArguments) *AccountQueryArguments {
	if queryArgs == nil {
		queryArgs = &AccountQueryArguments{
			Cursor: DefaultCursor,
		}
		return queryArgs
	}
	if queryArgs.Offset == nil {
		queryArgs.Offset = DefaultCursor.Offset
	}
	if queryArgs.Limit == nil {
		queryArgs.Limit = DefaultCursor.Limit
	}
	if queryArgs.OrderBy == nil {
		queryArgs.OrderBy = DefaultCursor.OrderBy
	}
	if queryArgs.Desc == nil {
		queryArgs.Desc = DefaultCursor.Desc
	}
	if queryArgs.Dead == nil {
		queryArgs.Dead = DefaultCursor.Dead
	}
	if queryArgs.After == nil {
		queryArgs.After = DefaultCursor.After
	}
	if queryArgs.First == nil {
		queryArgs.First = DefaultCursor.First
	}
	if queryArgs.Before == nil {
		queryArgs.Before = DefaultCursor.Before
	}
	if queryArgs.Last == nil {
		queryArgs.Last = DefaultCursor.Last
	}
	return queryArgs
}

// extension block
const graphQLAccountQueries = `
        allAccounts(where: AccountFilter, offset: Int, limit: Int, orderBy: String, desc: Boolean): AccountConnection!
        accountByID(id:ID!):Account
        accountBySubject(subject:String!):Account
    `

const graphQLAccountMutations = `
        insertAccounts(input: [InsertAccountInput!]!): [Account!]!
        updateAccounts(input: [UpdateAccountInput!]!): [Account!]!
        deleteAccounts(input: [DeleteAccountInput!]!): [ID!]!
    `

var graphQLAccountTypes = `
        type Account {
            id: ID!
            subject: String!
            email: String!
            createdDate: Time
            changedDate: Time
            deletedDate: Time
            usersSubject(offset: Int, limit: Int, orderBy: String, desc: Boolean): UserConnection!
        }

        type AccountConnection {
            pageInfo: PageInfo!
            edges: [AccountEdge]
            totalCount: Int
            accounts: [Account]
        }

        type AccountEdge {
            node: Account
            cursor: ID!
        }
    
        input AccountFilter {
            conjunction: FilterConjunction
            subject: String
            subject_like: String // LIKE
            subject_ilike: String // LIKE case insensitive
            subject_nlike: String	// NOT LIKE
            subject_nilike: String // NOT LIKE case insensitive
        }

        input InsertAccountInput {
            subject: String!
            email: String!
            createdDate: Time
            changedDate: Time
            deletedDate: Time
        }

        input UpdateAccountInput {
            id: ID!
            subject: String
            email: String
            createdDate: Time
            changedDate: Time
            deletedDate: Time
            _deletions: [String!]
        }

        input DeleteAccountInput {
            id: ID!
        }
    `

// GetAccountQueries specifies the GraphQL queries for Account
func (r *RootResolver) GetAccountQueries() string {
	return graphQLAccountQueries
}

// GetAccountMutations specifies the GraphQL mutations for Account
func (r *RootResolver) GetAccountMutations() string {
	return graphQLAccountMutations
}

// GetAccountTypes specifies the GraphQL types for Account
func (r *RootResolver) GetAccountTypes() string {
	return graphQLAccountTypes
}

// AccountResolver defines the GraphQL resolver for 'Account'.
type AccountResolver struct {
	ext  ResolverExtensions
	node *Account
}

// AccountResolver defines a GraphQL resolver for Account
func NewAccountResolver(node *Account, ext ResolverExtensions) *AccountResolver {
	return &AccountResolver{ext: ext, node: node}
}

// Node get node for AccountResolver
func (r AccountResolver) Node() *Account {
	return r.node
}
func (r AccountResolver) ID() graphql.ID             { return graphql.ID(strconv.Itoa(r.node.ID)) }
func (r AccountResolver) Subject() string            { return r.node.Subject }
func (r AccountResolver) Email() string              { return r.node.Email }
func (r AccountResolver) CreatedDate() *graphql.Time { return PointerGqlTime(r.node.CreatedDate) }
func (r AccountResolver) ChangedDate() *graphql.Time { return PointerGqlTime(r.node.ChangedDate) }
func (r AccountResolver) DeletedDate() *graphql.Time { return PointerGqlTime(r.node.DeletedDate) }
func (r AccountResolver) UsersSubject(ctx context.Context, queryArgs *UserQueryArguments) (*UserConnectionResolver, error) {
	if r.ext.verifier == nil {
		return nil, errors.New("enable ac, please set verifier")
	}
	if err := r.ext.verifier.VerifyRefAC(ctx, "Accounts", "RefGet", r); err != nil {
		return nil, errors.Wrap(err, "Accounts:RefGet")
	}

	if queryArgs != nil && (queryArgs.After != nil || queryArgs.First != nil || queryArgs.Before != nil || queryArgs.Last != nil) {
		return nil, errors.New("not implemented yet, use offset + limit for pagination")
	}

	queryArgs = ApplyUserQueryArgsDefaults(queryArgs)

	subject := r.node.Subject

	data, err := r.ext.storage.UsersBySubjectFK(r.ext.db, subject, queryArgs)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get Users")
	}

	count, err := r.ext.storage.CountUsersBySubjectFK(r.ext.db, subject, queryArgs)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get Users count")
	}

	return &UserConnectionResolver{
		ext:   r.ext,
		data:  data,
		count: int32(count),
	}, nil
}

// AccountByID generated by account_pk
func (r *RootResolver) AccountByID(ctx context.Context, args struct {
	ID graphql.ID
}) (*AccountResolver, error) {
	if r.ext.verifier == nil {
		return nil, errors.New("enable ac, please set verifier")
	}
	if err := r.ext.verifier.VerifyAC(ctx, "Accounts", "Get", args); err != nil {
		return nil, errors.Wrap(err, "Accounts:Get")
	}

	res, err := r.innerAccountByIDGraphQL(ctx, args)

	// event record
	if r.ext.recorder != nil {
		if err := r.ext.recorder.RecordEvent(ctx, "Accounts", "Get", res); err != nil {
			r.ext.logger.Warnf("unable to record event, resource:Accounts, action:Get, err:%v", err)
		}
	}
	return res, err
}

// innerAccountByIDGraphQL retrieves a row from '"public"."account"' as a Account.
// Generated from index 'account_pk'.
func (r *RootResolver) innerAccountByIDGraphQL(ctx context.Context, args struct {
	ID graphql.ID
}) (*AccountResolver, error) {

	arg0, err := strconv.Atoi(string(args.ID))
	if err != nil {
		return nil, errors.Wrap(err, `ID should be integer`)
	}

	data, err := r.ext.storage.AccountByID(r.ext.db, arg0)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, errors.Errorf(`account [`+"%v"+`] not found`, arg0)
		}
		return nil, errors.Wrap(err, `unable to get "public"."account"`)
	}

	return NewAccountResolver(data, r.ext), nil

}

// AccountBySubject generated by account_subject_unique_index
func (r *RootResolver) AccountBySubject(ctx context.Context, args struct {
	Subject string
}) (*AccountResolver, error) {
	if r.ext.verifier == nil {
		return nil, errors.New("enable ac, please set verifier")
	}
	if err := r.ext.verifier.VerifyAC(ctx, "Accounts.AccountBySubject", "NonPrimaryKeyGet", args); err != nil {
		return nil, errors.Wrap(err, "Accounts.AccountBySubject:NonPrimaryKeyGet")
	}

	res, err := r.innerAccountBySubjectGraphQL(ctx, args)

	// event record
	if r.ext.recorder != nil {
		if err := r.ext.recorder.RecordEvent(ctx, "Accounts.AccountBySubject", "NonPrimaryKeyGet", res); err != nil {
			r.ext.logger.Warnf("unable to record event, resource:Accounts.AccountBySubject, action:NonPrimaryKeyGet, err:%v", err)
		}
	}
	return res, err
}

// innerAccountBySubjectGraphQL retrieves a row from '"public"."account"' as a Account.
// Generated from index 'account_subject_unique_index'.
func (r *RootResolver) innerAccountBySubjectGraphQL(ctx context.Context, args struct {
	Subject string
}) (*AccountResolver, error) {

	arg0 := args.Subject

	data, err := r.ext.storage.AccountBySubject(r.ext.db, arg0)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, errors.Errorf(`account [`+"%v"+`] not found`, arg0)
		}
		return nil, errors.Wrap(err, `unable to get "public"."account"`)
	}

	return NewAccountResolver(data, r.ext), nil

}

// AccountConnectionResolver defines a GraphQL resolver for AccountConnection
type AccountConnectionResolver struct {
	ext ResolverExtensions

	data  []*Account
	count int32
}

// NewAccountConnectionResolver return a GraphQL resolver for AccountConnection
func NewAccountConnectionResolver(data []*Account, count int, ext ResolverExtensions) *AccountConnectionResolver {
	return &AccountConnectionResolver{
		ext:   ext,
		data:  data,
		count: int32(count),
	}
}

// PageInfo returns PageInfo
func (r AccountConnectionResolver) PageInfo() *PageInfoResolver {
	if len(r.data) == 0 {
		return &PageInfoResolver{}
	}

	return &PageInfoResolver{
		startCursor:     encodeCursor("Account", int(r.data[0].ID)),
		endCursor:       encodeCursor("Account", int(r.data[len(r.data)-1].ID)),
		hasNextPage:     false, // TODO
		hasPreviousPage: false, // TODO
	}
}

// Edges returns standard GraphQL edges
func (r AccountConnectionResolver) Edges() *[]*AccountEdgeResolver {
	edges := make([]*AccountEdgeResolver, len(r.data))

	for i := range r.data {
		edges[i] = NewAccountEdgeResolver(r.data[i], r.ext)
	}
	return &edges
}

// TotalCount returns total count
func (r AccountConnectionResolver) TotalCount() *int32 {
	return &r.count
}

// Accounts returns the list of Account
func (r AccountConnectionResolver) Accounts() *[]*AccountResolver {
	data := make([]*AccountResolver, len(r.data))
	for i := range r.data {
		data[i] = NewAccountResolver(r.data[i], r.ext)
	}
	return &data
}

// AccountEdgeResolver defines the Account edge
type AccountEdgeResolver struct {
	ext  ResolverExtensions
	node *Account
}

// NewAccountEdgeResolver return a GraphQL resolver for AccountEdgeResolver
func NewAccountEdgeResolver(node *Account, ext ResolverExtensions) *AccountEdgeResolver {
	return &AccountEdgeResolver{
		ext:  ext,
		node: node,
	}
}

// Node returns the Account node
func (r AccountEdgeResolver) Node() *AccountResolver {
	return NewAccountResolver(r.node, r.ext)
}

// Cursor returns the cursor
func (r AccountEdgeResolver) Cursor() graphql.ID {
	return encodeCursor("Account", int(r.node.ID))
}

// InsertAccountInput defines the insert Account mutation input
type InsertAccountInput struct {
	Subject     string
	Email       string
	CreatedDate *graphql.Time
	ChangedDate *graphql.Time
	DeletedDate *graphql.Time
}

// UpdateAccountInput defines the update Account mutation input
type UpdateAccountInput struct {
	ID          graphql.ID
	Subject     *string
	Email       *string
	CreatedDate *graphql.Time
	ChangedDate *graphql.Time
	DeletedDate *graphql.Time
	updateArguments
}

// DeleteAccountInput defines the delete Account mutation input
type DeleteAccountInput struct {
	ID graphql.ID
}

// AllAccounts is a graphQL endpoint of AllAccounts
func (r *RootResolver) AllAccounts(ctx context.Context, args *AccountQueryArguments) (*AccountConnectionResolver, error) {
	if r.ext.verifier == nil {
		return nil, errors.New("enable ac, please set verifier")
	}
	if err := r.ext.verifier.VerifyAC(ctx, "Accounts", "GetAll", args); err != nil {
		return nil, errors.Wrap(err, "Accounts:GetAll")
	}

	res, err := r.allAccounts(ctx, args)

	// event record
	if r.ext.recorder != nil {
		if err := r.ext.recorder.RecordEvent(ctx, "Accounts", "GetAll", res); err != nil {
			r.ext.logger.Warnf("unable to record event, resource:Accounts, action:GetAll, err:%v", err)
		}
	}
	return res, err
}

func (r *RootResolver) allAccounts(ctx context.Context, queryArgs *AccountQueryArguments) (*AccountConnectionResolver, error) {
	if queryArgs != nil && (queryArgs.After != nil || queryArgs.First != nil || queryArgs.Before != nil || queryArgs.Last != nil) {
		return nil, errors.New("not implemented yet, use offset + limit for pagination")
	}

	queryArgs = ApplyAccountQueryArgsDefaults(queryArgs)

	filterArgs, err := getAccountFilter(queryArgs.Where)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get Account filter")
	}
	queryArgs.filterArgs = filterArgs

	allAccount, err := r.ext.storage.GetAllAccount(r.ext.db, queryArgs)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get Account")
	}

	count, err := r.ext.storage.CountAllAccount(r.ext.db, queryArgs)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get count")
	}

	return &AccountConnectionResolver{
		ext:   r.ext,
		data:  allAccount,
		count: int32(count),
	}, nil
}

// InsertAccounts is a graphQL endpoint of InsertAccounts
func (r *RootResolver) InsertAccounts(ctx context.Context, args struct{ Input []InsertAccountInput }) ([]AccountResolver, error) {
	if r.ext.verifier == nil {
		return nil, errors.New("enable ac, please set verifier")
	}
	if err := r.ext.verifier.VerifyAC(ctx, "Accounts", "Insert", args); err != nil {
		return nil, errors.Wrap(err, "Accounts:Insert")
	}

	res, err := r.insertAccountGraphQL(ctx, args.Input)

	// event record
	if r.ext.recorder != nil {
		if err := r.ext.recorder.RecordEvent(ctx, "Accounts", "Insert", res); err != nil {
			r.ext.logger.Warnf("unable to record event, resource:Accounts, action:Insert, err:%v", err)
		}
	}
	return res, err
}

func (r *RootResolver) insertAccountGraphQL(ctx context.Context, items []InsertAccountInput) ([]AccountResolver, error) {
	results := make([]AccountResolver, len(items))
	for i := range items {
		input := items[i]

		f1 := input.Subject
		f2 := input.Email
		f3 := TimeGqlPointer(input.CreatedDate)
		f4 := TimeGqlPointer(input.ChangedDate)
		f5 := TimeGqlPointer(input.DeletedDate)
		node := &Account{
			Subject:     f1,
			Email:       f2,
			CreatedDate: f3,
			ChangedDate: f4,
			DeletedDate: f5,
		}
		if err := r.ext.storage.InsertAccountByFields(r.ext.db, node); err != nil {
			return nil, errors.Wrap(err, "unable to insert Account")
		}
		results[i] = AccountResolver{ext: r.ext, node: node}
	}
	return results, nil
}

// UpdateAccountGraphQL is the GraphQL end point for UpdateAccount
func (r *RootResolver) UpdateAccounts(ctx context.Context, args struct{ Input []UpdateAccountInput }) ([]AccountResolver, error) {
	if r.ext.verifier == nil {
		return nil, errors.New("enable ac, please set verifier")
	}
	if err := r.ext.verifier.VerifyAC(ctx, "Accounts", "Update", args); err != nil {
		return nil, errors.Wrap(err, "Accounts:Update")
	}

	res, err := r.updateAccountGraphQL(ctx, args.Input)

	// event record
	if r.ext.recorder != nil {
		if err := r.ext.recorder.RecordEvent(ctx, "Accounts", "Update", res); err != nil {
			r.ext.logger.Warnf("unable to record event, resource:Accounts, action:Update, err:%v", err)
		}
	}
	return res, err
}

func (r *RootResolver) updateAccountGraphQL(ctx context.Context, items []UpdateAccountInput) ([]AccountResolver, error) {
	results := make([]AccountResolver, len(items))
	for i := range items {
		input := items[i]
		id, err := strconv.Atoi(string(input.ID))
		if err != nil {
			return nil, errors.New("ID must be an integer")
		}

		node := &Account{ID: id}
		fields := make([]string, 0, 5)
		params := make([]interface{}, 0, 5)
		retCols := make([]string, 0, 5)
		retVars := make([]interface{}, 0, 5)

		if isDeletionFields(input.Deletions, "subject") {
			return nil, errors.New("couldn't set subject to null")
		}
		if input.Subject != nil {
			fields = append(fields, `"subject"`)
			params = append(params, *input.Subject)
			node.Subject = *input.Subject
		} else {
			retCols = append(retCols, `"subject"`)
			retVars = append(retVars, &node.Subject)
		}

		if isDeletionFields(input.Deletions, "email") {
			return nil, errors.New("couldn't set email to null")
		}
		if input.Email != nil {
			fields = append(fields, `"email"`)
			params = append(params, *input.Email)
			node.Email = *input.Email
		} else {
			retCols = append(retCols, `"email"`)
			retVars = append(retVars, &node.Email)
		}

		if isDeletionFields(input.Deletions, "createdDate") {
			fields = append(fields, `"created_date"`)
			params = append(params, sql.NullTime{})
			node.CreatedDate = sql.NullTime{}
		} else if input.CreatedDate != nil {
			fields = append(fields, `"created_date"`)
			params = append(params, input.CreatedDate.Time)
			node.CreatedDate = sql.NullTime{Time: input.CreatedDate.Time, Valid: true}
		} else {
			retCols = append(retCols, `"created_date"`)
			retVars = append(retVars, &node.CreatedDate)
		}

		if isDeletionFields(input.Deletions, "changedDate") {
			fields = append(fields, `"changed_date"`)
			params = append(params, sql.NullTime{})
			node.ChangedDate = sql.NullTime{}
		} else if input.ChangedDate != nil {
			fields = append(fields, `"changed_date"`)
			params = append(params, input.ChangedDate.Time)
			node.ChangedDate = sql.NullTime{Time: input.ChangedDate.Time, Valid: true}
		} else {
			retCols = append(retCols, `"changed_date"`)
			retVars = append(retVars, &node.ChangedDate)
		}

		if isDeletionFields(input.Deletions, "deletedDate") {
			fields = append(fields, `"deleted_date"`)
			params = append(params, sql.NullTime{})
			node.DeletedDate = sql.NullTime{}
		} else if input.DeletedDate != nil {
			fields = append(fields, `"deleted_date"`)
			params = append(params, input.DeletedDate.Time)
			node.DeletedDate = sql.NullTime{Time: input.DeletedDate.Time, Valid: true}
		} else {
			retCols = append(retCols, `"deleted_date"`)
			retVars = append(retVars, &node.DeletedDate)
		}
		if len(params) == 0 {
			return nil, errors.New("all fields are empty, unable to update")
		}

		if err := r.ext.storage.UpdateAccountByFields(r.ext.db, node, fields, retCols, params, retVars); err != nil {
			if err == sql.ErrNoRows {
				return nil, errors.Errorf(`Account [%d] not found`, node.ID)
			}
			return nil, err
		}

		results[i] = AccountResolver{ext: r.ext, node: node}
	}
	return results, nil
}

// DeleteAccountGraphQL is the GraphQL end point for DeleteAccount
func (r *RootResolver) DeleteAccounts(ctx context.Context, args struct{ Input []DeleteAccountInput }) ([]graphql.ID, error) {
	if r.ext.verifier == nil {
		return nil, errors.New("enable ac, please set verifier")
	}
	if err := r.ext.verifier.VerifyAC(ctx, "Accounts", "Delete", args); err != nil {
		return nil, errors.Wrap(err, "Accounts:Delete")
	}

	res, err := r.deleteAccountGraphQL(ctx, args.Input)

	// event record
	if r.ext.recorder != nil {
		if err := r.ext.recorder.RecordEvent(ctx, "Accounts", "Delete", res); err != nil {
			r.ext.logger.Warnf("unable to record event, resource:Accounts, action:Delete, err:%v", err)
		}
	}
	return res, err
}

func (r *RootResolver) deleteAccountGraphQL(ctx context.Context, items []DeleteAccountInput) ([]graphql.ID, error) {
	results := make([]graphql.ID, len(items))
	inputs := make([]*Account, len(items))

	for i := range items {
		input := items[i]

		id, err := strconv.Atoi(string(input.ID))
		if err != nil {
			return nil, errors.New("ID must be an integer")
		}

		results[i] = input.ID
		inputs[i] = &Account{ID: id}
	}

	err := r.ext.storage.DeleteAccounts(r.ext.db, inputs)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (r *RootResolver) getAccountGraphQLResources() []GraphQLResource {
	return []GraphQLResource{
		GraphQLResource{
			Name:     "Accounts",
			Describe: "This is a graphQL resource Accounts, have GetAll, Get, Insert, Update, Delete actions.",
		},
		GraphQLResource{
			Name:     "Accounts.AccountBySubject",
			Describe: "This is a graphQL resource Accounts.AccountBySubject, only have NonPrimaryKeyGet action.",
		},
	}
}
