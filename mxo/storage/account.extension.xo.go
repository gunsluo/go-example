// Package storage contains the types for schema.
package storage

// Code generated by xo. DO NOT EDIT.

import (
	"fmt"
)

// AccountFilter related to AccountQueryArguments
// struct field name contain table column name in Camel style and logic operator(lt, gt etc)
// only indexed column and special column defined in ExtraFilters declared in file extra_rules.yaml
type AccountFilter struct {
	Conjunction   *string // enum in "AND", "OR", nil(consider as single condition)
	Subject       *string `json:"subject"`        // equal to Subject
	SubjectLike   *string `json:"subject_like"`   // LIKE
	SubjectILike  *string `json:"subject_ilike"`  // ILIKE case-insensitive
	SubjectNLike  *string `json:"subject_nlike"`  // NOT LIKE
	SubjectNILike *string `json:"subject_nilike"` // NOT ILIKE case-insensitive
}

// AccountQueryArguments composed by Cursor, AccountFilter and sql filter string
type AccountQueryArguments struct {
	Cursor
	Where *AccountFilter

	// non-export field
	filterArgs *filterArguments
}

// getAccountFilter return the sql filter
func getAccountFilter(filter *AccountFilter) (*filterArguments, error) {
	if filter == nil {
		return nil, nil
	}
	conjunction := ""
	conjCnt := 0
	var filterPairs []*filterPair
	if filter.Conjunction != nil {
		conjunction = *filter.Conjunction
		if _, ok := sqlConjunctionMap[conjunction]; !ok {
			return nil, fmt.Errorf("unsupported conjunction:%v", filter.Conjunction)
		}
	}
	if filter.Subject != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "=", value: *filter.Subject})
	}
	if filter.SubjectLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "LIKE", value: *filter.SubjectLike})
	}
	if filter.SubjectILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "ILIKE", value: *filter.SubjectILike})
	}
	if filter.SubjectNLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "NOT LIKE", value: *filter.SubjectNLike})
	}
	if filter.SubjectNILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "subject", option: "NOT ILIKE", value: *filter.SubjectNILike})
	}
	if conjCnt == 0 {
		return nil, nil
	}
	if len(conjunction) > 0 && conjCnt < 2 {
		return nil, fmt.Errorf("invalid filter conjunction: %v need more than 2 parameter but have: %v", *filter.Conjunction, conjCnt)
	}
	if len(conjunction) == 0 && conjCnt != 1 {
		return nil, fmt.Errorf("multi field:%v should be connected by conjunction AND or OR", conjCnt)
	}
	filterArgs := &filterArguments{filterPairs: filterPairs, conjunction: conjunction, conjCnt: conjCnt}
	return filterArgs, nil
}

// ApplyAccountQueryArgsDefaults assigns default cursor values to non-nil fields.
func ApplyAccountQueryArgsDefaults(queryArgs *AccountQueryArguments) *AccountQueryArguments {
	if queryArgs == nil {
		queryArgs = &AccountQueryArguments{
			Cursor: DefaultCursor,
		}
		return queryArgs
	}
	if queryArgs.Offset == nil {
		queryArgs.Offset = DefaultCursor.Offset
	}
	if queryArgs.Limit == nil {
		queryArgs.Limit = DefaultCursor.Limit
	}
	if queryArgs.OrderBy == nil {
		queryArgs.OrderBy = DefaultCursor.OrderBy
	}
	if queryArgs.Desc == nil {
		queryArgs.Desc = DefaultCursor.Desc
	}
	if queryArgs.Dead == nil {
		queryArgs.Dead = DefaultCursor.Dead
	}
	if queryArgs.After == nil {
		queryArgs.After = DefaultCursor.After
	}
	if queryArgs.First == nil {
		queryArgs.First = DefaultCursor.First
	}
	if queryArgs.Before == nil {
		queryArgs.Before = DefaultCursor.Before
	}
	if queryArgs.Last == nil {
		queryArgs.Last = DefaultCursor.Last
	}
	return queryArgs
}
